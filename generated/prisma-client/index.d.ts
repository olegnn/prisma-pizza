// Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
// Please don't change this file manually but run `prisma generate` to update it.
// For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

import { DocumentNode } from "graphql";
import {
  makePrismaClientClass,
  BaseClientOptions,
  Model
} from "prisma-client-lib";
import { typeDefs } from "./prisma-schema";

export type AtLeastOne<T, U = { [K in keyof T]: Pick<T, K> }> = Partial<T> &
  U[keyof U];

export type Maybe<T> = T | undefined | null;

export interface Exists {
  image: (where?: ImageWhereInput) => Promise<boolean>;
  order: (where?: OrderWhereInput) => Promise<boolean>;
  price: (where?: PriceWhereInput) => Promise<boolean>;
  product: (where?: ProductWhereInput) => Promise<boolean>;
  productConfiguration: (
    where?: ProductConfigurationWhereInput
  ) => Promise<boolean>;
  productOrder: (where?: ProductOrderWhereInput) => Promise<boolean>;
  topping: (where?: ToppingWhereInput) => Promise<boolean>;
  toppingOrder: (where?: ToppingOrderWhereInput) => Promise<boolean>;
  user: (where?: UserWhereInput) => Promise<boolean>;
}

export interface Node {}

export type FragmentableArray<T> = Promise<Array<T>> & Fragmentable;

export interface Fragmentable {
  $fragment<T>(fragment: string | DocumentNode): Promise<T>;
}

export interface Prisma {
  $exists: Exists;
  $graphql: <T = any>(
    query: string,
    variables?: { [key: string]: any }
  ) => Promise<T>;

  /**
   * Queries
   */

  image: (where: ImageWhereUniqueInput) => ImageNullablePromise;
  images: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Image>;
  imagesConnection: (args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ImageConnectionPromise;
  order: (where: OrderWhereUniqueInput) => OrderNullablePromise;
  orders: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Order>;
  ordersConnection: (args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => OrderConnectionPromise;
  price: (where: PriceWhereUniqueInput) => PriceNullablePromise;
  prices: (args?: {
    where?: PriceWhereInput;
    orderBy?: PriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Price>;
  pricesConnection: (args?: {
    where?: PriceWhereInput;
    orderBy?: PriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => PriceConnectionPromise;
  product: (where: ProductWhereUniqueInput) => ProductNullablePromise;
  products: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Product>;
  productsConnection: (args?: {
    where?: ProductWhereInput;
    orderBy?: ProductOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConnectionPromise;
  productConfiguration: (
    where: ProductConfigurationWhereUniqueInput
  ) => ProductConfigurationNullablePromise;
  productConfigurations: (args?: {
    where?: ProductConfigurationWhereInput;
    orderBy?: ProductConfigurationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductConfiguration>;
  productConfigurationsConnection: (args?: {
    where?: ProductConfigurationWhereInput;
    orderBy?: ProductConfigurationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductConfigurationConnectionPromise;
  productOrder: (
    where: ProductOrderWhereUniqueInput
  ) => ProductOrderNullablePromise;
  productOrders: (args?: {
    where?: ProductOrderWhereInput;
    orderBy?: ProductOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ProductOrder>;
  productOrdersConnection: (args?: {
    where?: ProductOrderWhereInput;
    orderBy?: ProductOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ProductOrderConnectionPromise;
  topping: (where: ToppingWhereUniqueInput) => ToppingNullablePromise;
  toppings: (args?: {
    where?: ToppingWhereInput;
    orderBy?: ToppingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<Topping>;
  toppingsConnection: (args?: {
    where?: ToppingWhereInput;
    orderBy?: ToppingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ToppingConnectionPromise;
  toppingOrder: (
    where: ToppingOrderWhereUniqueInput
  ) => ToppingOrderNullablePromise;
  toppingOrders: (args?: {
    where?: ToppingOrderWhereInput;
    orderBy?: ToppingOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<ToppingOrder>;
  toppingOrdersConnection: (args?: {
    where?: ToppingOrderWhereInput;
    orderBy?: ToppingOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => ToppingOrderConnectionPromise;
  user: (where: UserWhereUniqueInput) => UserNullablePromise;
  users: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => FragmentableArray<User>;
  usersConnection: (args?: {
    where?: UserWhereInput;
    orderBy?: UserOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => UserConnectionPromise;
  node: (args: { id: ID_Output }) => Node;

  /**
   * Mutations
   */

  createImage: (data: ImageCreateInput) => ImagePromise;
  updateImage: (args: {
    data: ImageUpdateInput;
    where: ImageWhereUniqueInput;
  }) => ImagePromise;
  updateManyImages: (args: {
    data: ImageUpdateManyMutationInput;
    where?: ImageWhereInput;
  }) => BatchPayloadPromise;
  upsertImage: (args: {
    where: ImageWhereUniqueInput;
    create: ImageCreateInput;
    update: ImageUpdateInput;
  }) => ImagePromise;
  deleteImage: (where: ImageWhereUniqueInput) => ImagePromise;
  deleteManyImages: (where?: ImageWhereInput) => BatchPayloadPromise;
  createOrder: (data: OrderCreateInput) => OrderPromise;
  updateOrder: (args: {
    data: OrderUpdateInput;
    where: OrderWhereUniqueInput;
  }) => OrderPromise;
  updateManyOrders: (args: {
    data: OrderUpdateManyMutationInput;
    where?: OrderWhereInput;
  }) => BatchPayloadPromise;
  upsertOrder: (args: {
    where: OrderWhereUniqueInput;
    create: OrderCreateInput;
    update: OrderUpdateInput;
  }) => OrderPromise;
  deleteOrder: (where: OrderWhereUniqueInput) => OrderPromise;
  deleteManyOrders: (where?: OrderWhereInput) => BatchPayloadPromise;
  createPrice: (data: PriceCreateInput) => PricePromise;
  updatePrice: (args: {
    data: PriceUpdateInput;
    where: PriceWhereUniqueInput;
  }) => PricePromise;
  updateManyPrices: (args: {
    data: PriceUpdateManyMutationInput;
    where?: PriceWhereInput;
  }) => BatchPayloadPromise;
  upsertPrice: (args: {
    where: PriceWhereUniqueInput;
    create: PriceCreateInput;
    update: PriceUpdateInput;
  }) => PricePromise;
  deletePrice: (where: PriceWhereUniqueInput) => PricePromise;
  deleteManyPrices: (where?: PriceWhereInput) => BatchPayloadPromise;
  createProduct: (data: ProductCreateInput) => ProductPromise;
  updateProduct: (args: {
    data: ProductUpdateInput;
    where: ProductWhereUniqueInput;
  }) => ProductPromise;
  updateManyProducts: (args: {
    data: ProductUpdateManyMutationInput;
    where?: ProductWhereInput;
  }) => BatchPayloadPromise;
  upsertProduct: (args: {
    where: ProductWhereUniqueInput;
    create: ProductCreateInput;
    update: ProductUpdateInput;
  }) => ProductPromise;
  deleteProduct: (where: ProductWhereUniqueInput) => ProductPromise;
  deleteManyProducts: (where?: ProductWhereInput) => BatchPayloadPromise;
  createProductConfiguration: (
    data: ProductConfigurationCreateInput
  ) => ProductConfigurationPromise;
  updateProductConfiguration: (args: {
    data: ProductConfigurationUpdateInput;
    where: ProductConfigurationWhereUniqueInput;
  }) => ProductConfigurationPromise;
  updateManyProductConfigurations: (args: {
    data: ProductConfigurationUpdateManyMutationInput;
    where?: ProductConfigurationWhereInput;
  }) => BatchPayloadPromise;
  upsertProductConfiguration: (args: {
    where: ProductConfigurationWhereUniqueInput;
    create: ProductConfigurationCreateInput;
    update: ProductConfigurationUpdateInput;
  }) => ProductConfigurationPromise;
  deleteProductConfiguration: (
    where: ProductConfigurationWhereUniqueInput
  ) => ProductConfigurationPromise;
  deleteManyProductConfigurations: (
    where?: ProductConfigurationWhereInput
  ) => BatchPayloadPromise;
  createProductOrder: (data: ProductOrderCreateInput) => ProductOrderPromise;
  updateProductOrder: (args: {
    data: ProductOrderUpdateInput;
    where: ProductOrderWhereUniqueInput;
  }) => ProductOrderPromise;
  updateManyProductOrders: (args: {
    data: ProductOrderUpdateManyMutationInput;
    where?: ProductOrderWhereInput;
  }) => BatchPayloadPromise;
  upsertProductOrder: (args: {
    where: ProductOrderWhereUniqueInput;
    create: ProductOrderCreateInput;
    update: ProductOrderUpdateInput;
  }) => ProductOrderPromise;
  deleteProductOrder: (
    where: ProductOrderWhereUniqueInput
  ) => ProductOrderPromise;
  deleteManyProductOrders: (
    where?: ProductOrderWhereInput
  ) => BatchPayloadPromise;
  createTopping: (data: ToppingCreateInput) => ToppingPromise;
  updateTopping: (args: {
    data: ToppingUpdateInput;
    where: ToppingWhereUniqueInput;
  }) => ToppingPromise;
  updateManyToppings: (args: {
    data: ToppingUpdateManyMutationInput;
    where?: ToppingWhereInput;
  }) => BatchPayloadPromise;
  upsertTopping: (args: {
    where: ToppingWhereUniqueInput;
    create: ToppingCreateInput;
    update: ToppingUpdateInput;
  }) => ToppingPromise;
  deleteTopping: (where: ToppingWhereUniqueInput) => ToppingPromise;
  deleteManyToppings: (where?: ToppingWhereInput) => BatchPayloadPromise;
  createToppingOrder: (data: ToppingOrderCreateInput) => ToppingOrderPromise;
  updateToppingOrder: (args: {
    data: ToppingOrderUpdateInput;
    where: ToppingOrderWhereUniqueInput;
  }) => ToppingOrderPromise;
  updateManyToppingOrders: (args: {
    data: ToppingOrderUpdateManyMutationInput;
    where?: ToppingOrderWhereInput;
  }) => BatchPayloadPromise;
  upsertToppingOrder: (args: {
    where: ToppingOrderWhereUniqueInput;
    create: ToppingOrderCreateInput;
    update: ToppingOrderUpdateInput;
  }) => ToppingOrderPromise;
  deleteToppingOrder: (
    where: ToppingOrderWhereUniqueInput
  ) => ToppingOrderPromise;
  deleteManyToppingOrders: (
    where?: ToppingOrderWhereInput
  ) => BatchPayloadPromise;
  createUser: (data: UserCreateInput) => UserPromise;
  updateUser: (args: {
    data: UserUpdateInput;
    where: UserWhereUniqueInput;
  }) => UserPromise;
  updateManyUsers: (args: {
    data: UserUpdateManyMutationInput;
    where?: UserWhereInput;
  }) => BatchPayloadPromise;
  upsertUser: (args: {
    where: UserWhereUniqueInput;
    create: UserCreateInput;
    update: UserUpdateInput;
  }) => UserPromise;
  deleteUser: (where: UserWhereUniqueInput) => UserPromise;
  deleteManyUsers: (where?: UserWhereInput) => BatchPayloadPromise;

  /**
   * Subscriptions
   */

  $subscribe: Subscription;
}

export interface Subscription {
  image: (
    where?: ImageSubscriptionWhereInput
  ) => ImageSubscriptionPayloadSubscription;
  order: (
    where?: OrderSubscriptionWhereInput
  ) => OrderSubscriptionPayloadSubscription;
  price: (
    where?: PriceSubscriptionWhereInput
  ) => PriceSubscriptionPayloadSubscription;
  product: (
    where?: ProductSubscriptionWhereInput
  ) => ProductSubscriptionPayloadSubscription;
  productConfiguration: (
    where?: ProductConfigurationSubscriptionWhereInput
  ) => ProductConfigurationSubscriptionPayloadSubscription;
  productOrder: (
    where?: ProductOrderSubscriptionWhereInput
  ) => ProductOrderSubscriptionPayloadSubscription;
  topping: (
    where?: ToppingSubscriptionWhereInput
  ) => ToppingSubscriptionPayloadSubscription;
  toppingOrder: (
    where?: ToppingOrderSubscriptionWhereInput
  ) => ToppingOrderSubscriptionPayloadSubscription;
  user: (
    where?: UserSubscriptionWhereInput
  ) => UserSubscriptionPayloadSubscription;
}

export interface ClientConstructor<T> {
  new (options?: BaseClientOptions): T;
}

/**
 * Types
 */

export type ToppingOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "description_ASC"
  | "description_DESC"
  | "maxQuantity_ASC"
  | "maxQuantity_DESC";

export type Category = "Pizza" | "Drink" | "Dessert" | "Soup";

export type PriceOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "currency_ASC"
  | "currency_DESC"
  | "amount_ASC"
  | "amount_DESC";

export type ImageSize = "Large" | "Medium" | "Small";

export type Currency = "GBP" | "EUR" | "USD" | "RUB";

export type OrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "name_ASC"
  | "name_DESC"
  | "time_ASC"
  | "time_DESC"
  | "address1_ASC"
  | "address1_DESC"
  | "address2_ASC"
  | "address2_DESC"
  | "payment_ASC"
  | "payment_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type ProductOrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "quantity_ASC"
  | "quantity_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC";

export type ProductConfigurationOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "seqId_ASC"
  | "seqId_DESC"
  | "attr_ASC"
  | "attr_DESC"
  | "weight_ASC"
  | "weight_DESC"
  | "capacity_ASC"
  | "capacity_DESC";

export type UserOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "email_ASC"
  | "email_DESC"
  | "password_ASC"
  | "password_DESC"
  | "phone_ASC"
  | "phone_DESC"
  | "name_ASC"
  | "name_DESC"
  | "address1_ASC"
  | "address1_DESC"
  | "address2_ASC"
  | "address2_DESC"
  | "payment_ASC"
  | "payment_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "updatedAt_ASC"
  | "updatedAt_DESC";

export type MutationType = "CREATED" | "UPDATED" | "DELETED";

export type ToppingOrderOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "quantity_ASC"
  | "quantity_DESC";

export type ImageOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "size_ASC"
  | "size_DESC"
  | "source_ASC"
  | "source_DESC"
  | "alt_ASC"
  | "alt_DESC";

export type ProductOrderByInput =
  | "id_ASC"
  | "id_DESC"
  | "name_ASC"
  | "name_DESC"
  | "category_ASC"
  | "category_DESC"
  | "createdAt_ASC"
  | "createdAt_DESC"
  | "popularity_ASC"
  | "popularity_DESC"
  | "maxQuantity_ASC"
  | "maxQuantity_DESC"
  | "description_ASC"
  | "description_DESC";

export interface ProductOrderUpdateWithWhereUniqueNestedInput {
  where: ProductOrderWhereUniqueInput;
  data: ProductOrderUpdateDataInput;
}

export type ImageWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserCreateOneWithoutOrdersInput {
  create?: Maybe<UserCreateWithoutOrdersInput>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export interface ToppingUpdateOneRequiredInput {
  create?: Maybe<ToppingCreateInput>;
  update?: Maybe<ToppingUpdateDataInput>;
  upsert?: Maybe<ToppingUpsertNestedInput>;
  connect?: Maybe<ToppingWhereUniqueInput>;
}

export interface UserCreateWithoutOrdersInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  phone: String;
  name: String;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  payment?: Maybe<String>;
}

export interface PriceUpdateManyInput {
  create?: Maybe<PriceCreateInput[] | PriceCreateInput>;
  update?: Maybe<
    | PriceUpdateWithWhereUniqueNestedInput[]
    | PriceUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | PriceUpsertWithWhereUniqueNestedInput[]
    | PriceUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<PriceWhereUniqueInput[] | PriceWhereUniqueInput>;
  connect?: Maybe<PriceWhereUniqueInput[] | PriceWhereUniqueInput>;
  set?: Maybe<PriceWhereUniqueInput[] | PriceWhereUniqueInput>;
  disconnect?: Maybe<PriceWhereUniqueInput[] | PriceWhereUniqueInput>;
  deleteMany?: Maybe<PriceScalarWhereInput[] | PriceScalarWhereInput>;
  updateMany?: Maybe<
    PriceUpdateManyWithWhereNestedInput[] | PriceUpdateManyWithWhereNestedInput
  >;
}

export interface ProductOrderCreateManyInput {
  create?: Maybe<ProductOrderCreateInput[] | ProductOrderCreateInput>;
  connect?: Maybe<
    ProductOrderWhereUniqueInput[] | ProductOrderWhereUniqueInput
  >;
}

export interface UserSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<UserWhereInput>;
  AND?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  OR?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
  NOT?: Maybe<UserSubscriptionWhereInput[] | UserSubscriptionWhereInput>;
}

export interface ProductOrderCreateInput {
  id?: Maybe<ID_Input>;
  product: ProductCreateOneInput;
  quantity: Int;
  configuration?: Maybe<ProductConfigurationCreateOneInput>;
  toppings?: Maybe<ToppingOrderCreateManyInput>;
}

export interface ProductWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  category?: Maybe<Category>;
  category_not?: Maybe<Category>;
  category_in?: Maybe<Category[] | Category>;
  category_not_in?: Maybe<Category[] | Category>;
  configurations_every?: Maybe<ProductConfigurationWhereInput>;
  configurations_some?: Maybe<ProductConfigurationWhereInput>;
  configurations_none?: Maybe<ProductConfigurationWhereInput>;
  toppings_every?: Maybe<ToppingWhereInput>;
  toppings_some?: Maybe<ToppingWhereInput>;
  toppings_none?: Maybe<ToppingWhereInput>;
  images_every?: Maybe<ImageWhereInput>;
  images_some?: Maybe<ImageWhereInput>;
  images_none?: Maybe<ImageWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  popularity?: Maybe<Float>;
  popularity_not?: Maybe<Float>;
  popularity_in?: Maybe<Float[] | Float>;
  popularity_not_in?: Maybe<Float[] | Float>;
  popularity_lt?: Maybe<Float>;
  popularity_lte?: Maybe<Float>;
  popularity_gt?: Maybe<Float>;
  popularity_gte?: Maybe<Float>;
  maxQuantity?: Maybe<Int>;
  maxQuantity_not?: Maybe<Int>;
  maxQuantity_in?: Maybe<Int[] | Int>;
  maxQuantity_not_in?: Maybe<Int[] | Int>;
  maxQuantity_lt?: Maybe<Int>;
  maxQuantity_lte?: Maybe<Int>;
  maxQuantity_gt?: Maybe<Int>;
  maxQuantity_gte?: Maybe<Int>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  AND?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  OR?: Maybe<ProductWhereInput[] | ProductWhereInput>;
  NOT?: Maybe<ProductWhereInput[] | ProductWhereInput>;
}

export interface ProductCreateOneInput {
  create?: Maybe<ProductCreateInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export interface ProductConfigurationWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  seqId?: Maybe<Int>;
  seqId_not?: Maybe<Int>;
  seqId_in?: Maybe<Int[] | Int>;
  seqId_not_in?: Maybe<Int[] | Int>;
  seqId_lt?: Maybe<Int>;
  seqId_lte?: Maybe<Int>;
  seqId_gt?: Maybe<Int>;
  seqId_gte?: Maybe<Int>;
  attr?: Maybe<String>;
  attr_not?: Maybe<String>;
  attr_in?: Maybe<String[] | String>;
  attr_not_in?: Maybe<String[] | String>;
  attr_lt?: Maybe<String>;
  attr_lte?: Maybe<String>;
  attr_gt?: Maybe<String>;
  attr_gte?: Maybe<String>;
  attr_contains?: Maybe<String>;
  attr_not_contains?: Maybe<String>;
  attr_starts_with?: Maybe<String>;
  attr_not_starts_with?: Maybe<String>;
  attr_ends_with?: Maybe<String>;
  attr_not_ends_with?: Maybe<String>;
  prices_every?: Maybe<PriceWhereInput>;
  prices_some?: Maybe<PriceWhereInput>;
  prices_none?: Maybe<PriceWhereInput>;
  weight?: Maybe<Int>;
  weight_not?: Maybe<Int>;
  weight_in?: Maybe<Int[] | Int>;
  weight_not_in?: Maybe<Int[] | Int>;
  weight_lt?: Maybe<Int>;
  weight_lte?: Maybe<Int>;
  weight_gt?: Maybe<Int>;
  weight_gte?: Maybe<Int>;
  capacity?: Maybe<Int>;
  capacity_not?: Maybe<Int>;
  capacity_in?: Maybe<Int[] | Int>;
  capacity_not_in?: Maybe<Int[] | Int>;
  capacity_lt?: Maybe<Int>;
  capacity_lte?: Maybe<Int>;
  capacity_gt?: Maybe<Int>;
  capacity_gte?: Maybe<Int>;
  AND?: Maybe<
    ProductConfigurationWhereInput[] | ProductConfigurationWhereInput
  >;
  OR?: Maybe<ProductConfigurationWhereInput[] | ProductConfigurationWhereInput>;
  NOT?: Maybe<
    ProductConfigurationWhereInput[] | ProductConfigurationWhereInput
  >;
}

export interface ProductCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  category: Category;
  configurations?: Maybe<ProductConfigurationCreateManyInput>;
  toppings?: Maybe<ToppingCreateManyInput>;
  images?: Maybe<ImageCreateManyInput>;
  popularity?: Maybe<Float>;
  maxQuantity?: Maybe<Int>;
  description?: Maybe<String>;
}

export type OrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductConfigurationCreateManyInput {
  create?: Maybe<
    ProductConfigurationCreateInput[] | ProductConfigurationCreateInput
  >;
  connect?: Maybe<
    | ProductConfigurationWhereUniqueInput[]
    | ProductConfigurationWhereUniqueInput
  >;
}

export interface ToppingSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ToppingWhereInput>;
  AND?: Maybe<ToppingSubscriptionWhereInput[] | ToppingSubscriptionWhereInput>;
  OR?: Maybe<ToppingSubscriptionWhereInput[] | ToppingSubscriptionWhereInput>;
  NOT?: Maybe<ToppingSubscriptionWhereInput[] | ToppingSubscriptionWhereInput>;
}

export interface ProductConfigurationCreateInput {
  id?: Maybe<ID_Input>;
  seqId: Int;
  attr: String;
  prices?: Maybe<PriceCreateManyInput>;
  weight?: Maybe<Int>;
  capacity?: Maybe<Int>;
}

export interface ProductOrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductOrderWhereInput>;
  AND?: Maybe<
    ProductOrderSubscriptionWhereInput[] | ProductOrderSubscriptionWhereInput
  >;
  OR?: Maybe<
    ProductOrderSubscriptionWhereInput[] | ProductOrderSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ProductOrderSubscriptionWhereInput[] | ProductOrderSubscriptionWhereInput
  >;
}

export interface PriceCreateManyInput {
  create?: Maybe<PriceCreateInput[] | PriceCreateInput>;
  connect?: Maybe<PriceWhereUniqueInput[] | PriceWhereUniqueInput>;
}

export interface ProductSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductWhereInput>;
  AND?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  OR?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
  NOT?: Maybe<ProductSubscriptionWhereInput[] | ProductSubscriptionWhereInput>;
}

export interface PriceCreateInput {
  id?: Maybe<ID_Input>;
  currency: Currency;
  amount: Int;
}

export interface OrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<OrderWhereInput>;
  AND?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  OR?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
  NOT?: Maybe<OrderSubscriptionWhereInput[] | OrderSubscriptionWhereInput>;
}

export interface ToppingCreateManyInput {
  create?: Maybe<ToppingCreateInput[] | ToppingCreateInput>;
  connect?: Maybe<ToppingWhereUniqueInput[] | ToppingWhereUniqueInput>;
}

export interface UserUpdateManyMutationInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  name?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  payment?: Maybe<String>;
}

export interface ToppingCreateInput {
  id?: Maybe<ID_Input>;
  name: String;
  prices?: Maybe<PriceCreateManyInput>;
  image: ImageCreateOneInput;
  description: String;
  maxQuantity?: Maybe<Int>;
}

export interface OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput;
  data: OrderUpdateManyDataInput;
}

export interface ImageCreateOneInput {
  create?: Maybe<ImageCreateInput>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface OrderUpsertWithWhereUniqueWithoutUserInput {
  where: OrderWhereUniqueInput;
  update: OrderUpdateWithoutUserDataInput;
  create: OrderCreateWithoutUserInput;
}

export interface ImageCreateManyInput {
  create?: Maybe<ImageCreateInput[] | ImageCreateInput>;
  connect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
}

export interface OrderUpdateWithWhereUniqueWithoutUserInput {
  where: OrderWhereUniqueInput;
  data: OrderUpdateWithoutUserDataInput;
}

export interface ProductConfigurationCreateOneInput {
  create?: Maybe<ProductConfigurationCreateInput>;
  connect?: Maybe<ProductConfigurationWhereUniqueInput>;
}

export interface UserUpdateInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  name?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  payment?: Maybe<String>;
  orders?: Maybe<OrderUpdateManyWithoutUserInput>;
}

export interface ToppingOrderCreateManyInput {
  create?: Maybe<ToppingOrderCreateInput[] | ToppingOrderCreateInput>;
  connect?: Maybe<
    ToppingOrderWhereUniqueInput[] | ToppingOrderWhereUniqueInput
  >;
}

export interface OrderCreateWithoutUserInput {
  id?: Maybe<ID_Input>;
  products?: Maybe<ProductOrderCreateManyInput>;
  email: String;
  phone: String;
  name: String;
  time?: Maybe<DateTimeInput>;
  address1: String;
  address2: String;
  payment: String;
}

export interface ToppingOrderCreateInput {
  id?: Maybe<ID_Input>;
  topping: ToppingCreateOneInput;
  quantity?: Maybe<Int>;
}

export interface UserCreateInput {
  id?: Maybe<ID_Input>;
  email: String;
  password: String;
  phone: String;
  name: String;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  payment?: Maybe<String>;
  orders?: Maybe<OrderCreateManyWithoutUserInput>;
}

export interface ToppingCreateOneInput {
  create?: Maybe<ToppingCreateInput>;
  connect?: Maybe<ToppingWhereUniqueInput>;
}

export interface ImageWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  size?: Maybe<ImageSize>;
  size_not?: Maybe<ImageSize>;
  size_in?: Maybe<ImageSize[] | ImageSize>;
  size_not_in?: Maybe<ImageSize[] | ImageSize>;
  source?: Maybe<String>;
  source_not?: Maybe<String>;
  source_in?: Maybe<String[] | String>;
  source_not_in?: Maybe<String[] | String>;
  source_lt?: Maybe<String>;
  source_lte?: Maybe<String>;
  source_gt?: Maybe<String>;
  source_gte?: Maybe<String>;
  source_contains?: Maybe<String>;
  source_not_contains?: Maybe<String>;
  source_starts_with?: Maybe<String>;
  source_not_starts_with?: Maybe<String>;
  source_ends_with?: Maybe<String>;
  source_not_ends_with?: Maybe<String>;
  alt?: Maybe<String>;
  alt_not?: Maybe<String>;
  alt_in?: Maybe<String[] | String>;
  alt_not_in?: Maybe<String[] | String>;
  alt_lt?: Maybe<String>;
  alt_lte?: Maybe<String>;
  alt_gt?: Maybe<String>;
  alt_gte?: Maybe<String>;
  alt_contains?: Maybe<String>;
  alt_not_contains?: Maybe<String>;
  alt_starts_with?: Maybe<String>;
  alt_not_starts_with?: Maybe<String>;
  alt_ends_with?: Maybe<String>;
  alt_not_ends_with?: Maybe<String>;
  AND?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  OR?: Maybe<ImageWhereInput[] | ImageWhereInput>;
  NOT?: Maybe<ImageWhereInput[] | ImageWhereInput>;
}

export interface OrderUpdateInput {
  user?: Maybe<UserUpdateOneWithoutOrdersInput>;
  products?: Maybe<ProductOrderUpdateManyInput>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  name?: Maybe<String>;
  time?: Maybe<DateTimeInput>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  payment?: Maybe<String>;
}

export interface ToppingOrderUpdateInput {
  topping?: Maybe<ToppingUpdateOneRequiredInput>;
  quantity?: Maybe<Int>;
}

export interface UserUpdateOneWithoutOrdersInput {
  create?: Maybe<UserCreateWithoutOrdersInput>;
  update?: Maybe<UserUpdateWithoutOrdersDataInput>;
  upsert?: Maybe<UserUpsertWithoutOrdersInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<UserWhereUniqueInput>;
}

export type ProductConfigurationWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface UserUpdateWithoutOrdersDataInput {
  email?: Maybe<String>;
  password?: Maybe<String>;
  phone?: Maybe<String>;
  name?: Maybe<String>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  payment?: Maybe<String>;
}

export interface ProductOrderUpdateManyMutationInput {
  quantity?: Maybe<Int>;
}

export interface UserUpsertWithoutOrdersInput {
  update: UserUpdateWithoutOrdersDataInput;
  create: UserCreateWithoutOrdersInput;
}

export type ProductOrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductOrderUpdateManyInput {
  create?: Maybe<ProductOrderCreateInput[] | ProductOrderCreateInput>;
  update?: Maybe<
    | ProductOrderUpdateWithWhereUniqueNestedInput[]
    | ProductOrderUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProductOrderUpsertWithWhereUniqueNestedInput[]
    | ProductOrderUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ProductOrderWhereUniqueInput[] | ProductOrderWhereUniqueInput>;
  connect?: Maybe<
    ProductOrderWhereUniqueInput[] | ProductOrderWhereUniqueInput
  >;
  set?: Maybe<ProductOrderWhereUniqueInput[] | ProductOrderWhereUniqueInput>;
  disconnect?: Maybe<
    ProductOrderWhereUniqueInput[] | ProductOrderWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ProductOrderScalarWhereInput[] | ProductOrderScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductOrderUpdateManyWithWhereNestedInput[]
    | ProductOrderUpdateManyWithWhereNestedInput
  >;
}

export interface ProductConfigurationUpdateInput {
  seqId?: Maybe<Int>;
  attr?: Maybe<String>;
  prices?: Maybe<PriceUpdateManyInput>;
  weight?: Maybe<Int>;
  capacity?: Maybe<Int>;
}

export interface ToppingUpsertNestedInput {
  update: ToppingUpdateDataInput;
  create: ToppingCreateInput;
}

export type ToppingWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductOrderUpdateDataInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  quantity?: Maybe<Int>;
  configuration?: Maybe<ProductConfigurationUpdateOneInput>;
  toppings?: Maybe<ToppingOrderUpdateManyInput>;
}

export interface PriceUpdateManyMutationInput {
  currency?: Maybe<Currency>;
  amount?: Maybe<Int>;
}

export interface ProductUpdateOneRequiredInput {
  create?: Maybe<ProductCreateInput>;
  update?: Maybe<ProductUpdateDataInput>;
  upsert?: Maybe<ProductUpsertNestedInput>;
  connect?: Maybe<ProductWhereUniqueInput>;
}

export type ToppingOrderWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ProductUpdateDataInput {
  name?: Maybe<String>;
  category?: Maybe<Category>;
  configurations?: Maybe<ProductConfigurationUpdateManyInput>;
  toppings?: Maybe<ToppingUpdateManyInput>;
  images?: Maybe<ImageUpdateManyInput>;
  popularity?: Maybe<Float>;
  maxQuantity?: Maybe<Int>;
  description?: Maybe<String>;
}

export interface ProductOrderUpdateManyDataInput {
  quantity?: Maybe<Int>;
}

export interface ProductConfigurationUpdateManyInput {
  create?: Maybe<
    ProductConfigurationCreateInput[] | ProductConfigurationCreateInput
  >;
  update?: Maybe<
    | ProductConfigurationUpdateWithWhereUniqueNestedInput[]
    | ProductConfigurationUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ProductConfigurationUpsertWithWhereUniqueNestedInput[]
    | ProductConfigurationUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<
    | ProductConfigurationWhereUniqueInput[]
    | ProductConfigurationWhereUniqueInput
  >;
  connect?: Maybe<
    | ProductConfigurationWhereUniqueInput[]
    | ProductConfigurationWhereUniqueInput
  >;
  set?: Maybe<
    | ProductConfigurationWhereUniqueInput[]
    | ProductConfigurationWhereUniqueInput
  >;
  disconnect?: Maybe<
    | ProductConfigurationWhereUniqueInput[]
    | ProductConfigurationWhereUniqueInput
  >;
  deleteMany?: Maybe<
    | ProductConfigurationScalarWhereInput[]
    | ProductConfigurationScalarWhereInput
  >;
  updateMany?: Maybe<
    | ProductConfigurationUpdateManyWithWhereNestedInput[]
    | ProductConfigurationUpdateManyWithWhereNestedInput
  >;
}

export type UserWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
  email?: Maybe<String>;
}>;

export interface ProductConfigurationUpdateWithWhereUniqueNestedInput {
  where: ProductConfigurationWhereUniqueInput;
  data: ProductConfigurationUpdateDataInput;
}

export interface ProductOrderUpsertWithWhereUniqueNestedInput {
  where: ProductOrderWhereUniqueInput;
  update: ProductOrderUpdateDataInput;
  create: ProductOrderCreateInput;
}

export interface ProductConfigurationUpdateDataInput {
  seqId?: Maybe<Int>;
  attr?: Maybe<String>;
  prices?: Maybe<PriceUpdateManyInput>;
  weight?: Maybe<Int>;
  capacity?: Maybe<Int>;
}

export interface ToppingOrderUpdateManyWithWhereNestedInput {
  where: ToppingOrderScalarWhereInput;
  data: ToppingOrderUpdateManyDataInput;
}

export interface OrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  user?: Maybe<UserWhereInput>;
  products_every?: Maybe<ProductOrderWhereInput>;
  products_some?: Maybe<ProductOrderWhereInput>;
  products_none?: Maybe<ProductOrderWhereInput>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  address1?: Maybe<String>;
  address1_not?: Maybe<String>;
  address1_in?: Maybe<String[] | String>;
  address1_not_in?: Maybe<String[] | String>;
  address1_lt?: Maybe<String>;
  address1_lte?: Maybe<String>;
  address1_gt?: Maybe<String>;
  address1_gte?: Maybe<String>;
  address1_contains?: Maybe<String>;
  address1_not_contains?: Maybe<String>;
  address1_starts_with?: Maybe<String>;
  address1_not_starts_with?: Maybe<String>;
  address1_ends_with?: Maybe<String>;
  address1_not_ends_with?: Maybe<String>;
  address2?: Maybe<String>;
  address2_not?: Maybe<String>;
  address2_in?: Maybe<String[] | String>;
  address2_not_in?: Maybe<String[] | String>;
  address2_lt?: Maybe<String>;
  address2_lte?: Maybe<String>;
  address2_gt?: Maybe<String>;
  address2_gte?: Maybe<String>;
  address2_contains?: Maybe<String>;
  address2_not_contains?: Maybe<String>;
  address2_starts_with?: Maybe<String>;
  address2_not_starts_with?: Maybe<String>;
  address2_ends_with?: Maybe<String>;
  address2_not_ends_with?: Maybe<String>;
  payment?: Maybe<String>;
  payment_not?: Maybe<String>;
  payment_in?: Maybe<String[] | String>;
  payment_not_in?: Maybe<String[] | String>;
  payment_lt?: Maybe<String>;
  payment_lte?: Maybe<String>;
  payment_gt?: Maybe<String>;
  payment_gte?: Maybe<String>;
  payment_contains?: Maybe<String>;
  payment_not_contains?: Maybe<String>;
  payment_starts_with?: Maybe<String>;
  payment_not_starts_with?: Maybe<String>;
  payment_ends_with?: Maybe<String>;
  payment_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  OR?: Maybe<OrderWhereInput[] | OrderWhereInput>;
  NOT?: Maybe<OrderWhereInput[] | OrderWhereInput>;
}

export interface ImageCreateInput {
  id?: Maybe<ID_Input>;
  size: ImageSize;
  source: String;
  alt?: Maybe<String>;
}

export interface PriceUpdateWithWhereUniqueNestedInput {
  where: PriceWhereUniqueInput;
  data: PriceUpdateDataInput;
}

export interface ImageUpdateManyMutationInput {
  size?: Maybe<ImageSize>;
  source?: Maybe<String>;
  alt?: Maybe<String>;
}

export interface PriceUpdateDataInput {
  currency?: Maybe<Currency>;
  amount?: Maybe<Int>;
}

export interface ToppingOrderUpsertWithWhereUniqueNestedInput {
  where: ToppingOrderWhereUniqueInput;
  update: ToppingOrderUpdateDataInput;
  create: ToppingOrderCreateInput;
}

export interface PriceUpsertWithWhereUniqueNestedInput {
  where: PriceWhereUniqueInput;
  update: PriceUpdateDataInput;
  create: PriceCreateInput;
}

export interface UserWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  password?: Maybe<String>;
  password_not?: Maybe<String>;
  password_in?: Maybe<String[] | String>;
  password_not_in?: Maybe<String[] | String>;
  password_lt?: Maybe<String>;
  password_lte?: Maybe<String>;
  password_gt?: Maybe<String>;
  password_gte?: Maybe<String>;
  password_contains?: Maybe<String>;
  password_not_contains?: Maybe<String>;
  password_starts_with?: Maybe<String>;
  password_not_starts_with?: Maybe<String>;
  password_ends_with?: Maybe<String>;
  password_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  address1?: Maybe<String>;
  address1_not?: Maybe<String>;
  address1_in?: Maybe<String[] | String>;
  address1_not_in?: Maybe<String[] | String>;
  address1_lt?: Maybe<String>;
  address1_lte?: Maybe<String>;
  address1_gt?: Maybe<String>;
  address1_gte?: Maybe<String>;
  address1_contains?: Maybe<String>;
  address1_not_contains?: Maybe<String>;
  address1_starts_with?: Maybe<String>;
  address1_not_starts_with?: Maybe<String>;
  address1_ends_with?: Maybe<String>;
  address1_not_ends_with?: Maybe<String>;
  address2?: Maybe<String>;
  address2_not?: Maybe<String>;
  address2_in?: Maybe<String[] | String>;
  address2_not_in?: Maybe<String[] | String>;
  address2_lt?: Maybe<String>;
  address2_lte?: Maybe<String>;
  address2_gt?: Maybe<String>;
  address2_gte?: Maybe<String>;
  address2_contains?: Maybe<String>;
  address2_not_contains?: Maybe<String>;
  address2_starts_with?: Maybe<String>;
  address2_not_starts_with?: Maybe<String>;
  address2_ends_with?: Maybe<String>;
  address2_not_ends_with?: Maybe<String>;
  payment?: Maybe<String>;
  payment_not?: Maybe<String>;
  payment_in?: Maybe<String[] | String>;
  payment_not_in?: Maybe<String[] | String>;
  payment_lt?: Maybe<String>;
  payment_lte?: Maybe<String>;
  payment_gt?: Maybe<String>;
  payment_gte?: Maybe<String>;
  payment_contains?: Maybe<String>;
  payment_not_contains?: Maybe<String>;
  payment_starts_with?: Maybe<String>;
  payment_not_starts_with?: Maybe<String>;
  payment_ends_with?: Maybe<String>;
  payment_not_ends_with?: Maybe<String>;
  orders_every?: Maybe<OrderWhereInput>;
  orders_some?: Maybe<OrderWhereInput>;
  orders_none?: Maybe<OrderWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<UserWhereInput[] | UserWhereInput>;
  OR?: Maybe<UserWhereInput[] | UserWhereInput>;
  NOT?: Maybe<UserWhereInput[] | UserWhereInput>;
}

export interface PriceScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  currency?: Maybe<Currency>;
  currency_not?: Maybe<Currency>;
  currency_in?: Maybe<Currency[] | Currency>;
  currency_not_in?: Maybe<Currency[] | Currency>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<PriceScalarWhereInput[] | PriceScalarWhereInput>;
  OR?: Maybe<PriceScalarWhereInput[] | PriceScalarWhereInput>;
  NOT?: Maybe<PriceScalarWhereInput[] | PriceScalarWhereInput>;
}

export interface ToppingOrderSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ToppingOrderWhereInput>;
  AND?: Maybe<
    ToppingOrderSubscriptionWhereInput[] | ToppingOrderSubscriptionWhereInput
  >;
  OR?: Maybe<
    ToppingOrderSubscriptionWhereInput[] | ToppingOrderSubscriptionWhereInput
  >;
  NOT?: Maybe<
    ToppingOrderSubscriptionWhereInput[] | ToppingOrderSubscriptionWhereInput
  >;
}

export interface PriceUpdateManyWithWhereNestedInput {
  where: PriceScalarWhereInput;
  data: PriceUpdateManyDataInput;
}

export interface ToppingWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  prices_every?: Maybe<PriceWhereInput>;
  prices_some?: Maybe<PriceWhereInput>;
  prices_none?: Maybe<PriceWhereInput>;
  image?: Maybe<ImageWhereInput>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  maxQuantity?: Maybe<Int>;
  maxQuantity_not?: Maybe<Int>;
  maxQuantity_in?: Maybe<Int[] | Int>;
  maxQuantity_not_in?: Maybe<Int[] | Int>;
  maxQuantity_lt?: Maybe<Int>;
  maxQuantity_lte?: Maybe<Int>;
  maxQuantity_gt?: Maybe<Int>;
  maxQuantity_gte?: Maybe<Int>;
  AND?: Maybe<ToppingWhereInput[] | ToppingWhereInput>;
  OR?: Maybe<ToppingWhereInput[] | ToppingWhereInput>;
  NOT?: Maybe<ToppingWhereInput[] | ToppingWhereInput>;
}

export interface PriceUpdateManyDataInput {
  currency?: Maybe<Currency>;
  amount?: Maybe<Int>;
}

export interface ProductConfigurationSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ProductConfigurationWhereInput>;
  AND?: Maybe<
    | ProductConfigurationSubscriptionWhereInput[]
    | ProductConfigurationSubscriptionWhereInput
  >;
  OR?: Maybe<
    | ProductConfigurationSubscriptionWhereInput[]
    | ProductConfigurationSubscriptionWhereInput
  >;
  NOT?: Maybe<
    | ProductConfigurationSubscriptionWhereInput[]
    | ProductConfigurationSubscriptionWhereInput
  >;
}

export interface ProductConfigurationUpsertWithWhereUniqueNestedInput {
  where: ProductConfigurationWhereUniqueInput;
  update: ProductConfigurationUpdateDataInput;
  create: ProductConfigurationCreateInput;
}

export interface ImageSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<ImageWhereInput>;
  AND?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  OR?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
  NOT?: Maybe<ImageSubscriptionWhereInput[] | ImageSubscriptionWhereInput>;
}

export interface ProductConfigurationScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  seqId?: Maybe<Int>;
  seqId_not?: Maybe<Int>;
  seqId_in?: Maybe<Int[] | Int>;
  seqId_not_in?: Maybe<Int[] | Int>;
  seqId_lt?: Maybe<Int>;
  seqId_lte?: Maybe<Int>;
  seqId_gt?: Maybe<Int>;
  seqId_gte?: Maybe<Int>;
  attr?: Maybe<String>;
  attr_not?: Maybe<String>;
  attr_in?: Maybe<String[] | String>;
  attr_not_in?: Maybe<String[] | String>;
  attr_lt?: Maybe<String>;
  attr_lte?: Maybe<String>;
  attr_gt?: Maybe<String>;
  attr_gte?: Maybe<String>;
  attr_contains?: Maybe<String>;
  attr_not_contains?: Maybe<String>;
  attr_starts_with?: Maybe<String>;
  attr_not_starts_with?: Maybe<String>;
  attr_ends_with?: Maybe<String>;
  attr_not_ends_with?: Maybe<String>;
  weight?: Maybe<Int>;
  weight_not?: Maybe<Int>;
  weight_in?: Maybe<Int[] | Int>;
  weight_not_in?: Maybe<Int[] | Int>;
  weight_lt?: Maybe<Int>;
  weight_lte?: Maybe<Int>;
  weight_gt?: Maybe<Int>;
  weight_gte?: Maybe<Int>;
  capacity?: Maybe<Int>;
  capacity_not?: Maybe<Int>;
  capacity_in?: Maybe<Int[] | Int>;
  capacity_not_in?: Maybe<Int[] | Int>;
  capacity_lt?: Maybe<Int>;
  capacity_lte?: Maybe<Int>;
  capacity_gt?: Maybe<Int>;
  capacity_gte?: Maybe<Int>;
  AND?: Maybe<
    | ProductConfigurationScalarWhereInput[]
    | ProductConfigurationScalarWhereInput
  >;
  OR?: Maybe<
    | ProductConfigurationScalarWhereInput[]
    | ProductConfigurationScalarWhereInput
  >;
  NOT?: Maybe<
    | ProductConfigurationScalarWhereInput[]
    | ProductConfigurationScalarWhereInput
  >;
}

export interface OrderScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  email?: Maybe<String>;
  email_not?: Maybe<String>;
  email_in?: Maybe<String[] | String>;
  email_not_in?: Maybe<String[] | String>;
  email_lt?: Maybe<String>;
  email_lte?: Maybe<String>;
  email_gt?: Maybe<String>;
  email_gte?: Maybe<String>;
  email_contains?: Maybe<String>;
  email_not_contains?: Maybe<String>;
  email_starts_with?: Maybe<String>;
  email_not_starts_with?: Maybe<String>;
  email_ends_with?: Maybe<String>;
  email_not_ends_with?: Maybe<String>;
  phone?: Maybe<String>;
  phone_not?: Maybe<String>;
  phone_in?: Maybe<String[] | String>;
  phone_not_in?: Maybe<String[] | String>;
  phone_lt?: Maybe<String>;
  phone_lte?: Maybe<String>;
  phone_gt?: Maybe<String>;
  phone_gte?: Maybe<String>;
  phone_contains?: Maybe<String>;
  phone_not_contains?: Maybe<String>;
  phone_starts_with?: Maybe<String>;
  phone_not_starts_with?: Maybe<String>;
  phone_ends_with?: Maybe<String>;
  phone_not_ends_with?: Maybe<String>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  time?: Maybe<DateTimeInput>;
  time_not?: Maybe<DateTimeInput>;
  time_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  time_lt?: Maybe<DateTimeInput>;
  time_lte?: Maybe<DateTimeInput>;
  time_gt?: Maybe<DateTimeInput>;
  time_gte?: Maybe<DateTimeInput>;
  address1?: Maybe<String>;
  address1_not?: Maybe<String>;
  address1_in?: Maybe<String[] | String>;
  address1_not_in?: Maybe<String[] | String>;
  address1_lt?: Maybe<String>;
  address1_lte?: Maybe<String>;
  address1_gt?: Maybe<String>;
  address1_gte?: Maybe<String>;
  address1_contains?: Maybe<String>;
  address1_not_contains?: Maybe<String>;
  address1_starts_with?: Maybe<String>;
  address1_not_starts_with?: Maybe<String>;
  address1_ends_with?: Maybe<String>;
  address1_not_ends_with?: Maybe<String>;
  address2?: Maybe<String>;
  address2_not?: Maybe<String>;
  address2_in?: Maybe<String[] | String>;
  address2_not_in?: Maybe<String[] | String>;
  address2_lt?: Maybe<String>;
  address2_lte?: Maybe<String>;
  address2_gt?: Maybe<String>;
  address2_gte?: Maybe<String>;
  address2_contains?: Maybe<String>;
  address2_not_contains?: Maybe<String>;
  address2_starts_with?: Maybe<String>;
  address2_not_starts_with?: Maybe<String>;
  address2_ends_with?: Maybe<String>;
  address2_not_ends_with?: Maybe<String>;
  payment?: Maybe<String>;
  payment_not?: Maybe<String>;
  payment_in?: Maybe<String[] | String>;
  payment_not_in?: Maybe<String[] | String>;
  payment_lt?: Maybe<String>;
  payment_lte?: Maybe<String>;
  payment_gt?: Maybe<String>;
  payment_gte?: Maybe<String>;
  payment_contains?: Maybe<String>;
  payment_not_contains?: Maybe<String>;
  payment_starts_with?: Maybe<String>;
  payment_not_starts_with?: Maybe<String>;
  payment_ends_with?: Maybe<String>;
  payment_not_ends_with?: Maybe<String>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  updatedAt?: Maybe<DateTimeInput>;
  updatedAt_not?: Maybe<DateTimeInput>;
  updatedAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  updatedAt_lt?: Maybe<DateTimeInput>;
  updatedAt_lte?: Maybe<DateTimeInput>;
  updatedAt_gt?: Maybe<DateTimeInput>;
  updatedAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  OR?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  NOT?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
}

export interface ProductConfigurationUpdateManyWithWhereNestedInput {
  where: ProductConfigurationScalarWhereInput;
  data: ProductConfigurationUpdateManyDataInput;
}

export interface OrderUpdateManyWithoutUserInput {
  create?: Maybe<OrderCreateWithoutUserInput[] | OrderCreateWithoutUserInput>;
  delete?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  set?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  disconnect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
  update?: Maybe<
    | OrderUpdateWithWhereUniqueWithoutUserInput[]
    | OrderUpdateWithWhereUniqueWithoutUserInput
  >;
  upsert?: Maybe<
    | OrderUpsertWithWhereUniqueWithoutUserInput[]
    | OrderUpsertWithWhereUniqueWithoutUserInput
  >;
  deleteMany?: Maybe<OrderScalarWhereInput[] | OrderScalarWhereInput>;
  updateMany?: Maybe<
    OrderUpdateManyWithWhereNestedInput[] | OrderUpdateManyWithWhereNestedInput
  >;
}

export interface ProductConfigurationUpdateManyDataInput {
  seqId?: Maybe<Int>;
  attr?: Maybe<String>;
  weight?: Maybe<Int>;
  capacity?: Maybe<Int>;
}

export interface OrderCreateManyWithoutUserInput {
  create?: Maybe<OrderCreateWithoutUserInput[] | OrderCreateWithoutUserInput>;
  connect?: Maybe<OrderWhereUniqueInput[] | OrderWhereUniqueInput>;
}

export interface ToppingUpdateManyInput {
  create?: Maybe<ToppingCreateInput[] | ToppingCreateInput>;
  update?: Maybe<
    | ToppingUpdateWithWhereUniqueNestedInput[]
    | ToppingUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ToppingUpsertWithWhereUniqueNestedInput[]
    | ToppingUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ToppingWhereUniqueInput[] | ToppingWhereUniqueInput>;
  connect?: Maybe<ToppingWhereUniqueInput[] | ToppingWhereUniqueInput>;
  set?: Maybe<ToppingWhereUniqueInput[] | ToppingWhereUniqueInput>;
  disconnect?: Maybe<ToppingWhereUniqueInput[] | ToppingWhereUniqueInput>;
  deleteMany?: Maybe<ToppingScalarWhereInput[] | ToppingScalarWhereInput>;
  updateMany?: Maybe<
    | ToppingUpdateManyWithWhereNestedInput[]
    | ToppingUpdateManyWithWhereNestedInput
  >;
}

export interface ToppingOrderUpdateManyMutationInput {
  quantity?: Maybe<Int>;
}

export interface ToppingUpdateWithWhereUniqueNestedInput {
  where: ToppingWhereUniqueInput;
  data: ToppingUpdateDataInput;
}

export interface ToppingUpdateInput {
  name?: Maybe<String>;
  prices?: Maybe<PriceUpdateManyInput>;
  image?: Maybe<ImageUpdateOneRequiredInput>;
  description?: Maybe<String>;
  maxQuantity?: Maybe<Int>;
}

export interface ToppingUpdateDataInput {
  name?: Maybe<String>;
  prices?: Maybe<PriceUpdateManyInput>;
  image?: Maybe<ImageUpdateOneRequiredInput>;
  description?: Maybe<String>;
  maxQuantity?: Maybe<Int>;
}

export interface ProductConfigurationUpdateManyMutationInput {
  seqId?: Maybe<Int>;
  attr?: Maybe<String>;
  weight?: Maybe<Int>;
  capacity?: Maybe<Int>;
}

export interface ImageUpdateOneRequiredInput {
  create?: Maybe<ImageCreateInput>;
  update?: Maybe<ImageUpdateDataInput>;
  upsert?: Maybe<ImageUpsertNestedInput>;
  connect?: Maybe<ImageWhereUniqueInput>;
}

export interface ProductUpdateInput {
  name?: Maybe<String>;
  category?: Maybe<Category>;
  configurations?: Maybe<ProductConfigurationUpdateManyInput>;
  toppings?: Maybe<ToppingUpdateManyInput>;
  images?: Maybe<ImageUpdateManyInput>;
  popularity?: Maybe<Float>;
  maxQuantity?: Maybe<Int>;
  description?: Maybe<String>;
}

export interface ImageUpdateDataInput {
  size?: Maybe<ImageSize>;
  source?: Maybe<String>;
  alt?: Maybe<String>;
}

export interface OrderUpdateManyMutationInput {
  email?: Maybe<String>;
  phone?: Maybe<String>;
  name?: Maybe<String>;
  time?: Maybe<DateTimeInput>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  payment?: Maybe<String>;
}

export interface ImageUpsertNestedInput {
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface ProductOrderScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  AND?: Maybe<ProductOrderScalarWhereInput[] | ProductOrderScalarWhereInput>;
  OR?: Maybe<ProductOrderScalarWhereInput[] | ProductOrderScalarWhereInput>;
  NOT?: Maybe<ProductOrderScalarWhereInput[] | ProductOrderScalarWhereInput>;
}

export interface ToppingUpsertWithWhereUniqueNestedInput {
  where: ToppingWhereUniqueInput;
  update: ToppingUpdateDataInput;
  create: ToppingCreateInput;
}

export interface ToppingOrderScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  AND?: Maybe<ToppingOrderScalarWhereInput[] | ToppingOrderScalarWhereInput>;
  OR?: Maybe<ToppingOrderScalarWhereInput[] | ToppingOrderScalarWhereInput>;
  NOT?: Maybe<ToppingOrderScalarWhereInput[] | ToppingOrderScalarWhereInput>;
}

export interface ToppingScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  name?: Maybe<String>;
  name_not?: Maybe<String>;
  name_in?: Maybe<String[] | String>;
  name_not_in?: Maybe<String[] | String>;
  name_lt?: Maybe<String>;
  name_lte?: Maybe<String>;
  name_gt?: Maybe<String>;
  name_gte?: Maybe<String>;
  name_contains?: Maybe<String>;
  name_not_contains?: Maybe<String>;
  name_starts_with?: Maybe<String>;
  name_not_starts_with?: Maybe<String>;
  name_ends_with?: Maybe<String>;
  name_not_ends_with?: Maybe<String>;
  description?: Maybe<String>;
  description_not?: Maybe<String>;
  description_in?: Maybe<String[] | String>;
  description_not_in?: Maybe<String[] | String>;
  description_lt?: Maybe<String>;
  description_lte?: Maybe<String>;
  description_gt?: Maybe<String>;
  description_gte?: Maybe<String>;
  description_contains?: Maybe<String>;
  description_not_contains?: Maybe<String>;
  description_starts_with?: Maybe<String>;
  description_not_starts_with?: Maybe<String>;
  description_ends_with?: Maybe<String>;
  description_not_ends_with?: Maybe<String>;
  maxQuantity?: Maybe<Int>;
  maxQuantity_not?: Maybe<Int>;
  maxQuantity_in?: Maybe<Int[] | Int>;
  maxQuantity_not_in?: Maybe<Int[] | Int>;
  maxQuantity_lt?: Maybe<Int>;
  maxQuantity_lte?: Maybe<Int>;
  maxQuantity_gt?: Maybe<Int>;
  maxQuantity_gte?: Maybe<Int>;
  AND?: Maybe<ToppingScalarWhereInput[] | ToppingScalarWhereInput>;
  OR?: Maybe<ToppingScalarWhereInput[] | ToppingScalarWhereInput>;
  NOT?: Maybe<ToppingScalarWhereInput[] | ToppingScalarWhereInput>;
}

export interface ProductOrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  product?: Maybe<ProductWhereInput>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  configuration?: Maybe<ProductConfigurationWhereInput>;
  toppings_every?: Maybe<ToppingOrderWhereInput>;
  toppings_some?: Maybe<ToppingOrderWhereInput>;
  toppings_none?: Maybe<ToppingOrderWhereInput>;
  AND?: Maybe<ProductOrderWhereInput[] | ProductOrderWhereInput>;
  OR?: Maybe<ProductOrderWhereInput[] | ProductOrderWhereInput>;
  NOT?: Maybe<ProductOrderWhereInput[] | ProductOrderWhereInput>;
}

export interface ToppingUpdateManyWithWhereNestedInput {
  where: ToppingScalarWhereInput;
  data: ToppingUpdateManyDataInput;
}

export interface ToppingOrderWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  topping?: Maybe<ToppingWhereInput>;
  createdAt?: Maybe<DateTimeInput>;
  createdAt_not?: Maybe<DateTimeInput>;
  createdAt_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_not_in?: Maybe<DateTimeInput[] | DateTimeInput>;
  createdAt_lt?: Maybe<DateTimeInput>;
  createdAt_lte?: Maybe<DateTimeInput>;
  createdAt_gt?: Maybe<DateTimeInput>;
  createdAt_gte?: Maybe<DateTimeInput>;
  quantity?: Maybe<Int>;
  quantity_not?: Maybe<Int>;
  quantity_in?: Maybe<Int[] | Int>;
  quantity_not_in?: Maybe<Int[] | Int>;
  quantity_lt?: Maybe<Int>;
  quantity_lte?: Maybe<Int>;
  quantity_gt?: Maybe<Int>;
  quantity_gte?: Maybe<Int>;
  AND?: Maybe<ToppingOrderWhereInput[] | ToppingOrderWhereInput>;
  OR?: Maybe<ToppingOrderWhereInput[] | ToppingOrderWhereInput>;
  NOT?: Maybe<ToppingOrderWhereInput[] | ToppingOrderWhereInput>;
}

export interface ToppingUpdateManyDataInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  maxQuantity?: Maybe<Int>;
}

export interface OrderUpdateManyDataInput {
  email?: Maybe<String>;
  phone?: Maybe<String>;
  name?: Maybe<String>;
  time?: Maybe<DateTimeInput>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  payment?: Maybe<String>;
}

export interface ImageUpdateManyInput {
  create?: Maybe<ImageCreateInput[] | ImageCreateInput>;
  update?: Maybe<
    | ImageUpdateWithWhereUniqueNestedInput[]
    | ImageUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ImageUpsertWithWhereUniqueNestedInput[]
    | ImageUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  connect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  set?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  disconnect?: Maybe<ImageWhereUniqueInput[] | ImageWhereUniqueInput>;
  deleteMany?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  updateMany?: Maybe<
    ImageUpdateManyWithWhereNestedInput[] | ImageUpdateManyWithWhereNestedInput
  >;
}

export type PriceWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface ImageUpdateWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  data: ImageUpdateDataInput;
}

export interface ToppingUpdateManyMutationInput {
  name?: Maybe<String>;
  description?: Maybe<String>;
  maxQuantity?: Maybe<Int>;
}

export interface ImageUpsertWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput;
  update: ImageUpdateDataInput;
  create: ImageCreateInput;
}

export interface ProductUpdateManyMutationInput {
  name?: Maybe<String>;
  category?: Maybe<Category>;
  popularity?: Maybe<Float>;
  maxQuantity?: Maybe<Int>;
  description?: Maybe<String>;
}

export interface ImageScalarWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  size?: Maybe<ImageSize>;
  size_not?: Maybe<ImageSize>;
  size_in?: Maybe<ImageSize[] | ImageSize>;
  size_not_in?: Maybe<ImageSize[] | ImageSize>;
  source?: Maybe<String>;
  source_not?: Maybe<String>;
  source_in?: Maybe<String[] | String>;
  source_not_in?: Maybe<String[] | String>;
  source_lt?: Maybe<String>;
  source_lte?: Maybe<String>;
  source_gt?: Maybe<String>;
  source_gte?: Maybe<String>;
  source_contains?: Maybe<String>;
  source_not_contains?: Maybe<String>;
  source_starts_with?: Maybe<String>;
  source_not_starts_with?: Maybe<String>;
  source_ends_with?: Maybe<String>;
  source_not_ends_with?: Maybe<String>;
  alt?: Maybe<String>;
  alt_not?: Maybe<String>;
  alt_in?: Maybe<String[] | String>;
  alt_not_in?: Maybe<String[] | String>;
  alt_lt?: Maybe<String>;
  alt_lte?: Maybe<String>;
  alt_gt?: Maybe<String>;
  alt_gte?: Maybe<String>;
  alt_contains?: Maybe<String>;
  alt_not_contains?: Maybe<String>;
  alt_starts_with?: Maybe<String>;
  alt_not_starts_with?: Maybe<String>;
  alt_ends_with?: Maybe<String>;
  alt_not_ends_with?: Maybe<String>;
  AND?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  OR?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
  NOT?: Maybe<ImageScalarWhereInput[] | ImageScalarWhereInput>;
}

export interface ProductOrderUpdateManyWithWhereNestedInput {
  where: ProductOrderScalarWhereInput;
  data: ProductOrderUpdateManyDataInput;
}

export interface ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput;
  data: ImageUpdateManyDataInput;
}

export interface ImageUpdateInput {
  size?: Maybe<ImageSize>;
  source?: Maybe<String>;
  alt?: Maybe<String>;
}

export interface ImageUpdateManyDataInput {
  size?: Maybe<ImageSize>;
  source?: Maybe<String>;
  alt?: Maybe<String>;
}

export interface PriceWhereInput {
  id?: Maybe<ID_Input>;
  id_not?: Maybe<ID_Input>;
  id_in?: Maybe<ID_Input[] | ID_Input>;
  id_not_in?: Maybe<ID_Input[] | ID_Input>;
  id_lt?: Maybe<ID_Input>;
  id_lte?: Maybe<ID_Input>;
  id_gt?: Maybe<ID_Input>;
  id_gte?: Maybe<ID_Input>;
  id_contains?: Maybe<ID_Input>;
  id_not_contains?: Maybe<ID_Input>;
  id_starts_with?: Maybe<ID_Input>;
  id_not_starts_with?: Maybe<ID_Input>;
  id_ends_with?: Maybe<ID_Input>;
  id_not_ends_with?: Maybe<ID_Input>;
  currency?: Maybe<Currency>;
  currency_not?: Maybe<Currency>;
  currency_in?: Maybe<Currency[] | Currency>;
  currency_not_in?: Maybe<Currency[] | Currency>;
  amount?: Maybe<Int>;
  amount_not?: Maybe<Int>;
  amount_in?: Maybe<Int[] | Int>;
  amount_not_in?: Maybe<Int[] | Int>;
  amount_lt?: Maybe<Int>;
  amount_lte?: Maybe<Int>;
  amount_gt?: Maybe<Int>;
  amount_gte?: Maybe<Int>;
  AND?: Maybe<PriceWhereInput[] | PriceWhereInput>;
  OR?: Maybe<PriceWhereInput[] | PriceWhereInput>;
  NOT?: Maybe<PriceWhereInput[] | PriceWhereInput>;
}

export interface ProductUpsertNestedInput {
  update: ProductUpdateDataInput;
  create: ProductCreateInput;
}

export interface OrderUpdateWithoutUserDataInput {
  products?: Maybe<ProductOrderUpdateManyInput>;
  email?: Maybe<String>;
  phone?: Maybe<String>;
  name?: Maybe<String>;
  time?: Maybe<DateTimeInput>;
  address1?: Maybe<String>;
  address2?: Maybe<String>;
  payment?: Maybe<String>;
}

export interface ProductConfigurationUpdateOneInput {
  create?: Maybe<ProductConfigurationCreateInput>;
  update?: Maybe<ProductConfigurationUpdateDataInput>;
  upsert?: Maybe<ProductConfigurationUpsertNestedInput>;
  delete?: Maybe<Boolean>;
  disconnect?: Maybe<Boolean>;
  connect?: Maybe<ProductConfigurationWhereUniqueInput>;
}

export interface ProductOrderUpdateInput {
  product?: Maybe<ProductUpdateOneRequiredInput>;
  quantity?: Maybe<Int>;
  configuration?: Maybe<ProductConfigurationUpdateOneInput>;
  toppings?: Maybe<ToppingOrderUpdateManyInput>;
}

export interface ToppingOrderUpdateDataInput {
  topping?: Maybe<ToppingUpdateOneRequiredInput>;
  quantity?: Maybe<Int>;
}

export interface ToppingOrderUpdateWithWhereUniqueNestedInput {
  where: ToppingOrderWhereUniqueInput;
  data: ToppingOrderUpdateDataInput;
}

export interface ToppingOrderUpdateManyInput {
  create?: Maybe<ToppingOrderCreateInput[] | ToppingOrderCreateInput>;
  update?: Maybe<
    | ToppingOrderUpdateWithWhereUniqueNestedInput[]
    | ToppingOrderUpdateWithWhereUniqueNestedInput
  >;
  upsert?: Maybe<
    | ToppingOrderUpsertWithWhereUniqueNestedInput[]
    | ToppingOrderUpsertWithWhereUniqueNestedInput
  >;
  delete?: Maybe<ToppingOrderWhereUniqueInput[] | ToppingOrderWhereUniqueInput>;
  connect?: Maybe<
    ToppingOrderWhereUniqueInput[] | ToppingOrderWhereUniqueInput
  >;
  set?: Maybe<ToppingOrderWhereUniqueInput[] | ToppingOrderWhereUniqueInput>;
  disconnect?: Maybe<
    ToppingOrderWhereUniqueInput[] | ToppingOrderWhereUniqueInput
  >;
  deleteMany?: Maybe<
    ToppingOrderScalarWhereInput[] | ToppingOrderScalarWhereInput
  >;
  updateMany?: Maybe<
    | ToppingOrderUpdateManyWithWhereNestedInput[]
    | ToppingOrderUpdateManyWithWhereNestedInput
  >;
}

export interface ProductConfigurationUpsertNestedInput {
  update: ProductConfigurationUpdateDataInput;
  create: ProductConfigurationCreateInput;
}

export interface PriceUpdateInput {
  currency?: Maybe<Currency>;
  amount?: Maybe<Int>;
}

export type ProductWhereUniqueInput = AtLeastOne<{
  id: Maybe<ID_Input>;
}>;

export interface PriceSubscriptionWhereInput {
  mutation_in?: Maybe<MutationType[] | MutationType>;
  updatedFields_contains?: Maybe<String>;
  updatedFields_contains_every?: Maybe<String[] | String>;
  updatedFields_contains_some?: Maybe<String[] | String>;
  node?: Maybe<PriceWhereInput>;
  AND?: Maybe<PriceSubscriptionWhereInput[] | PriceSubscriptionWhereInput>;
  OR?: Maybe<PriceSubscriptionWhereInput[] | PriceSubscriptionWhereInput>;
  NOT?: Maybe<PriceSubscriptionWhereInput[] | PriceSubscriptionWhereInput>;
}

export interface OrderCreateInput {
  id?: Maybe<ID_Input>;
  user?: Maybe<UserCreateOneWithoutOrdersInput>;
  products?: Maybe<ProductOrderCreateManyInput>;
  email: String;
  phone: String;
  name: String;
  time?: Maybe<DateTimeInput>;
  address1: String;
  address2: String;
  payment: String;
}

export interface ToppingOrderUpdateManyDataInput {
  quantity?: Maybe<Int>;
}

export interface NodeNode {
  id: ID_Output;
}

export interface UserPreviousValues {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  name: String;
  address1?: String;
  address2?: String;
  payment?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPreviousValuesPromise
  extends Promise<UserPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  payment: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserPreviousValuesSubscription
  extends Promise<AsyncIterator<UserPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  payment: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ImageConnection {
  pageInfo: PageInfo;
  edges: ImageEdge[];
}

export interface ImageConnectionPromise
  extends Promise<ImageConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ImageEdge>>() => T;
  aggregate: <T = AggregateImagePromise>() => T;
}

export interface ImageConnectionSubscription
  extends Promise<AsyncIterator<ImageConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ImageEdgeSubscription>>>() => T;
  aggregate: <T = AggregateImageSubscription>() => T;
}

export interface User {
  id: ID_Output;
  email: String;
  password: String;
  phone: String;
  name: String;
  address1?: String;
  address2?: String;
  payment?: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface UserPromise extends Promise<User>, Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  payment: () => Promise<String>;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface UserSubscription
  extends Promise<AsyncIterator<User>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  password: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  payment: () => Promise<AsyncIterator<String>>;
  orders: <T = Promise<AsyncIterator<OrderSubscription>>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface UserNullablePromise
  extends Promise<User | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  password: () => Promise<String>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  payment: () => Promise<String>;
  orders: <T = FragmentableArray<Order>>(args?: {
    where?: OrderWhereInput;
    orderBy?: OrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface Price {
  id: ID_Output;
  currency: Currency;
  amount: Int;
}

export interface PricePromise extends Promise<Price>, Fragmentable {
  id: () => Promise<ID_Output>;
  currency: () => Promise<Currency>;
  amount: () => Promise<Int>;
}

export interface PriceSubscription
  extends Promise<AsyncIterator<Price>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface PriceNullablePromise
  extends Promise<Price | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  currency: () => Promise<Currency>;
  amount: () => Promise<Int>;
}

export interface BatchPayload {
  count: Long;
}

export interface BatchPayloadPromise
  extends Promise<BatchPayload>,
    Fragmentable {
  count: () => Promise<Long>;
}

export interface BatchPayloadSubscription
  extends Promise<AsyncIterator<BatchPayload>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Long>>;
}

export interface PageInfo {
  hasNextPage: Boolean;
  hasPreviousPage: Boolean;
  startCursor?: String;
  endCursor?: String;
}

export interface PageInfoPromise extends Promise<PageInfo>, Fragmentable {
  hasNextPage: () => Promise<Boolean>;
  hasPreviousPage: () => Promise<Boolean>;
  startCursor: () => Promise<String>;
  endCursor: () => Promise<String>;
}

export interface PageInfoSubscription
  extends Promise<AsyncIterator<PageInfo>>,
    Fragmentable {
  hasNextPage: () => Promise<AsyncIterator<Boolean>>;
  hasPreviousPage: () => Promise<AsyncIterator<Boolean>>;
  startCursor: () => Promise<AsyncIterator<String>>;
  endCursor: () => Promise<AsyncIterator<String>>;
}

export interface UserEdge {
  node: User;
  cursor: String;
}

export interface UserEdgePromise extends Promise<UserEdge>, Fragmentable {
  node: <T = UserPromise>() => T;
  cursor: () => Promise<String>;
}

export interface UserEdgeSubscription
  extends Promise<AsyncIterator<UserEdge>>,
    Fragmentable {
  node: <T = UserSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ToppingOrderPreviousValues {
  id: ID_Output;
  createdAt: DateTimeOutput;
  quantity?: Int;
}

export interface ToppingOrderPreviousValuesPromise
  extends Promise<ToppingOrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  createdAt: () => Promise<DateTimeOutput>;
  quantity: () => Promise<Int>;
}

export interface ToppingOrderPreviousValuesSubscription
  extends Promise<AsyncIterator<ToppingOrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  quantity: () => Promise<AsyncIterator<Int>>;
}

export interface ToppingPreviousValues {
  id: ID_Output;
  name: String;
  description: String;
  maxQuantity?: Int;
}

export interface ToppingPreviousValuesPromise
  extends Promise<ToppingPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  description: () => Promise<String>;
  maxQuantity: () => Promise<Int>;
}

export interface ToppingPreviousValuesSubscription
  extends Promise<AsyncIterator<ToppingPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  description: () => Promise<AsyncIterator<String>>;
  maxQuantity: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateUser {
  count: Int;
}

export interface AggregateUserPromise
  extends Promise<AggregateUser>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateUserSubscription
  extends Promise<AsyncIterator<AggregateUser>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConfiguration {
  id: ID_Output;
  seqId: Int;
  attr: String;
  weight?: Int;
  capacity?: Int;
}

export interface ProductConfigurationPromise
  extends Promise<ProductConfiguration>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seqId: () => Promise<Int>;
  attr: () => Promise<String>;
  prices: <T = FragmentableArray<Price>>(args?: {
    where?: PriceWhereInput;
    orderBy?: PriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  weight: () => Promise<Int>;
  capacity: () => Promise<Int>;
}

export interface ProductConfigurationSubscription
  extends Promise<AsyncIterator<ProductConfiguration>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  seqId: () => Promise<AsyncIterator<Int>>;
  attr: () => Promise<AsyncIterator<String>>;
  prices: <T = Promise<AsyncIterator<PriceSubscription>>>(args?: {
    where?: PriceWhereInput;
    orderBy?: PriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  weight: () => Promise<AsyncIterator<Int>>;
  capacity: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConfigurationNullablePromise
  extends Promise<ProductConfiguration | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seqId: () => Promise<Int>;
  attr: () => Promise<String>;
  prices: <T = FragmentableArray<Price>>(args?: {
    where?: PriceWhereInput;
    orderBy?: PriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  weight: () => Promise<Int>;
  capacity: () => Promise<Int>;
}

export interface UserConnection {
  pageInfo: PageInfo;
  edges: UserEdge[];
}

export interface UserConnectionPromise
  extends Promise<UserConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<UserEdge>>() => T;
  aggregate: <T = AggregateUserPromise>() => T;
}

export interface UserConnectionSubscription
  extends Promise<AsyncIterator<UserConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<UserEdgeSubscription>>>() => T;
  aggregate: <T = AggregateUserSubscription>() => T;
}

export interface ToppingOrderConnection {
  pageInfo: PageInfo;
  edges: ToppingOrderEdge[];
}

export interface ToppingOrderConnectionPromise
  extends Promise<ToppingOrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ToppingOrderEdge>>() => T;
  aggregate: <T = AggregateToppingOrderPromise>() => T;
}

export interface ToppingOrderConnectionSubscription
  extends Promise<AsyncIterator<ToppingOrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ToppingOrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateToppingOrderSubscription>() => T;
}

export interface AggregateToppingOrder {
  count: Int;
}

export interface AggregateToppingOrderPromise
  extends Promise<AggregateToppingOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateToppingOrderSubscription
  extends Promise<AsyncIterator<AggregateToppingOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ToppingEdge {
  node: Topping;
  cursor: String;
}

export interface ToppingEdgePromise extends Promise<ToppingEdge>, Fragmentable {
  node: <T = ToppingPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ToppingEdgeSubscription
  extends Promise<AsyncIterator<ToppingEdge>>,
    Fragmentable {
  node: <T = ToppingSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Image {
  id: ID_Output;
  size: ImageSize;
  source: String;
  alt?: String;
}

export interface ImagePromise extends Promise<Image>, Fragmentable {
  id: () => Promise<ID_Output>;
  size: () => Promise<ImageSize>;
  source: () => Promise<String>;
  alt: () => Promise<String>;
}

export interface ImageSubscription
  extends Promise<AsyncIterator<Image>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  size: () => Promise<AsyncIterator<ImageSize>>;
  source: () => Promise<AsyncIterator<String>>;
  alt: () => Promise<AsyncIterator<String>>;
}

export interface ImageNullablePromise
  extends Promise<Image | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  size: () => Promise<ImageSize>;
  source: () => Promise<String>;
  alt: () => Promise<String>;
}

export interface AggregateProductOrder {
  count: Int;
}

export interface AggregateProductOrderPromise
  extends Promise<AggregateProductOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductOrderSubscription
  extends Promise<AsyncIterator<AggregateProductOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageSubscriptionPayload {
  mutation: MutationType;
  node: Image;
  updatedFields: String[];
  previousValues: ImagePreviousValues;
}

export interface ImageSubscriptionPayloadPromise
  extends Promise<ImageSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ImagePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ImagePreviousValuesPromise>() => T;
}

export interface ImageSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ImageSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ImageSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ImagePreviousValuesSubscription>() => T;
}

export interface ProductOrderConnection {
  pageInfo: PageInfo;
  edges: ProductOrderEdge[];
}

export interface ProductOrderConnectionPromise
  extends Promise<ProductOrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductOrderEdge>>() => T;
  aggregate: <T = AggregateProductOrderPromise>() => T;
}

export interface ProductOrderConnectionSubscription
  extends Promise<AsyncIterator<ProductOrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductOrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductOrderSubscription>() => T;
}

export interface ImagePreviousValues {
  id: ID_Output;
  size: ImageSize;
  source: String;
  alt?: String;
}

export interface ImagePreviousValuesPromise
  extends Promise<ImagePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  size: () => Promise<ImageSize>;
  source: () => Promise<String>;
  alt: () => Promise<String>;
}

export interface ImagePreviousValuesSubscription
  extends Promise<AsyncIterator<ImagePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  size: () => Promise<AsyncIterator<ImageSize>>;
  source: () => Promise<AsyncIterator<String>>;
  alt: () => Promise<AsyncIterator<String>>;
}

export interface ProductConfigurationEdge {
  node: ProductConfiguration;
  cursor: String;
}

export interface ProductConfigurationEdgePromise
  extends Promise<ProductConfigurationEdge>,
    Fragmentable {
  node: <T = ProductConfigurationPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductConfigurationEdgeSubscription
  extends Promise<AsyncIterator<ProductConfigurationEdge>>,
    Fragmentable {
  node: <T = ProductConfigurationSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ToppingOrderSubscriptionPayload {
  mutation: MutationType;
  node: ToppingOrder;
  updatedFields: String[];
  previousValues: ToppingOrderPreviousValues;
}

export interface ToppingOrderSubscriptionPayloadPromise
  extends Promise<ToppingOrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ToppingOrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ToppingOrderPreviousValuesPromise>() => T;
}

export interface ToppingOrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ToppingOrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ToppingOrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ToppingOrderPreviousValuesSubscription>() => T;
}

export interface AggregateProduct {
  count: Int;
}

export interface AggregateProductPromise
  extends Promise<AggregateProduct>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductSubscription
  extends Promise<AsyncIterator<AggregateProduct>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface OrderSubscriptionPayload {
  mutation: MutationType;
  node: Order;
  updatedFields: String[];
  previousValues: OrderPreviousValues;
}

export interface OrderSubscriptionPayloadPromise
  extends Promise<OrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = OrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = OrderPreviousValuesPromise>() => T;
}

export interface OrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<OrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = OrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = OrderPreviousValuesSubscription>() => T;
}

export interface ProductConnection {
  pageInfo: PageInfo;
  edges: ProductEdge[];
}

export interface ProductConnectionPromise
  extends Promise<ProductConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductEdge>>() => T;
  aggregate: <T = AggregateProductPromise>() => T;
}

export interface ProductConnectionSubscription
  extends Promise<AsyncIterator<ProductConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ProductEdgeSubscription>>>() => T;
  aggregate: <T = AggregateProductSubscription>() => T;
}

export interface OrderPreviousValues {
  id: ID_Output;
  email: String;
  phone: String;
  name: String;
  time?: DateTimeOutput;
  address1: String;
  address2: String;
  payment: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrderPreviousValuesPromise
  extends Promise<OrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  time: () => Promise<DateTimeOutput>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  payment: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderPreviousValuesSubscription
  extends Promise<AsyncIterator<OrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  payment: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface PriceEdge {
  node: Price;
  cursor: String;
}

export interface PriceEdgePromise extends Promise<PriceEdge>, Fragmentable {
  node: <T = PricePromise>() => T;
  cursor: () => Promise<String>;
}

export interface PriceEdgeSubscription
  extends Promise<AsyncIterator<PriceEdge>>,
    Fragmentable {
  node: <T = PriceSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Product {
  id: ID_Output;
  name: String;
  category: Category;
  createdAt: DateTimeOutput;
  popularity?: Float;
  maxQuantity?: Int;
  description?: String;
}

export interface ProductPromise extends Promise<Product>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<Category>;
  configurations: <T = FragmentableArray<ProductConfiguration>>(args?: {
    where?: ProductConfigurationWhereInput;
    orderBy?: ProductConfigurationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  toppings: <T = FragmentableArray<Topping>>(args?: {
    where?: ToppingWhereInput;
    orderBy?: ToppingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  popularity: () => Promise<Float>;
  maxQuantity: () => Promise<Int>;
  description: () => Promise<String>;
}

export interface ProductSubscription
  extends Promise<AsyncIterator<Product>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<Category>>;
  configurations: <
    T = Promise<AsyncIterator<ProductConfigurationSubscription>>
  >(args?: {
    where?: ProductConfigurationWhereInput;
    orderBy?: ProductConfigurationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  toppings: <T = Promise<AsyncIterator<ToppingSubscription>>>(args?: {
    where?: ToppingWhereInput;
    orderBy?: ToppingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = Promise<AsyncIterator<ImageSubscription>>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  popularity: () => Promise<AsyncIterator<Float>>;
  maxQuantity: () => Promise<AsyncIterator<Int>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface ProductNullablePromise
  extends Promise<Product | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<Category>;
  configurations: <T = FragmentableArray<ProductConfiguration>>(args?: {
    where?: ProductConfigurationWhereInput;
    orderBy?: ProductConfigurationOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  toppings: <T = FragmentableArray<Topping>>(args?: {
    where?: ToppingWhereInput;
    orderBy?: ToppingOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  images: <T = FragmentableArray<Image>>(args?: {
    where?: ImageWhereInput;
    orderBy?: ImageOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  createdAt: () => Promise<DateTimeOutput>;
  popularity: () => Promise<Float>;
  maxQuantity: () => Promise<Int>;
  description: () => Promise<String>;
}

export interface AggregateOrder {
  count: Int;
}

export interface AggregateOrderPromise
  extends Promise<AggregateOrder>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateOrderSubscription
  extends Promise<AsyncIterator<AggregateOrder>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface PriceSubscriptionPayload {
  mutation: MutationType;
  node: Price;
  updatedFields: String[];
  previousValues: PricePreviousValues;
}

export interface PriceSubscriptionPayloadPromise
  extends Promise<PriceSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = PricePromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = PricePreviousValuesPromise>() => T;
}

export interface PriceSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<PriceSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = PriceSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = PricePreviousValuesSubscription>() => T;
}

export interface OrderConnection {
  pageInfo: PageInfo;
  edges: OrderEdge[];
}

export interface OrderConnectionPromise
  extends Promise<OrderConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<OrderEdge>>() => T;
  aggregate: <T = AggregateOrderPromise>() => T;
}

export interface OrderConnectionSubscription
  extends Promise<AsyncIterator<OrderConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<OrderEdgeSubscription>>>() => T;
  aggregate: <T = AggregateOrderSubscription>() => T;
}

export interface PricePreviousValues {
  id: ID_Output;
  currency: Currency;
  amount: Int;
}

export interface PricePreviousValuesPromise
  extends Promise<PricePreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  currency: () => Promise<Currency>;
  amount: () => Promise<Int>;
}

export interface PricePreviousValuesSubscription
  extends Promise<AsyncIterator<PricePreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  currency: () => Promise<AsyncIterator<Currency>>;
  amount: () => Promise<AsyncIterator<Int>>;
}

export interface UserSubscriptionPayload {
  mutation: MutationType;
  node: User;
  updatedFields: String[];
  previousValues: UserPreviousValues;
}

export interface UserSubscriptionPayloadPromise
  extends Promise<UserSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = UserPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = UserPreviousValuesPromise>() => T;
}

export interface UserSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<UserSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = UserSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = UserPreviousValuesSubscription>() => T;
}

export interface ProductOrder {
  id: ID_Output;
  quantity: Int;
  createdAt: DateTimeOutput;
}

export interface ProductOrderPromise
  extends Promise<ProductOrder>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  quantity: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  configuration: <T = ProductConfigurationPromise>() => T;
  toppings: <T = FragmentableArray<ToppingOrder>>(args?: {
    where?: ToppingOrderWhereInput;
    orderBy?: ToppingOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductOrderSubscription
  extends Promise<AsyncIterator<ProductOrder>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  product: <T = ProductSubscription>() => T;
  quantity: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  configuration: <T = ProductConfigurationSubscription>() => T;
  toppings: <T = Promise<AsyncIterator<ToppingOrderSubscription>>>(args?: {
    where?: ToppingOrderWhereInput;
    orderBy?: ToppingOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ProductOrderNullablePromise
  extends Promise<ProductOrder | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  product: <T = ProductPromise>() => T;
  quantity: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
  configuration: <T = ProductConfigurationPromise>() => T;
  toppings: <T = FragmentableArray<ToppingOrder>>(args?: {
    where?: ToppingOrderWhereInput;
    orderBy?: ToppingOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
}

export interface ToppingOrderEdge {
  node: ToppingOrder;
  cursor: String;
}

export interface ToppingOrderEdgePromise
  extends Promise<ToppingOrderEdge>,
    Fragmentable {
  node: <T = ToppingOrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ToppingOrderEdgeSubscription
  extends Promise<AsyncIterator<ToppingOrderEdge>>,
    Fragmentable {
  node: <T = ToppingOrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductSubscriptionPayload {
  mutation: MutationType;
  node: Product;
  updatedFields: String[];
  previousValues: ProductPreviousValues;
}

export interface ProductSubscriptionPayloadPromise
  extends Promise<ProductSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductPreviousValuesPromise>() => T;
}

export interface ProductSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductPreviousValuesSubscription>() => T;
}

export interface ToppingConnection {
  pageInfo: PageInfo;
  edges: ToppingEdge[];
}

export interface ToppingConnectionPromise
  extends Promise<ToppingConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ToppingEdge>>() => T;
  aggregate: <T = AggregateToppingPromise>() => T;
}

export interface ToppingConnectionSubscription
  extends Promise<AsyncIterator<ToppingConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<ToppingEdgeSubscription>>>() => T;
  aggregate: <T = AggregateToppingSubscription>() => T;
}

export interface ProductPreviousValues {
  id: ID_Output;
  name: String;
  category: Category;
  createdAt: DateTimeOutput;
  popularity?: Float;
  maxQuantity?: Int;
  description?: String;
}

export interface ProductPreviousValuesPromise
  extends Promise<ProductPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  category: () => Promise<Category>;
  createdAt: () => Promise<DateTimeOutput>;
  popularity: () => Promise<Float>;
  maxQuantity: () => Promise<Int>;
  description: () => Promise<String>;
}

export interface ProductPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  category: () => Promise<AsyncIterator<Category>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  popularity: () => Promise<AsyncIterator<Float>>;
  maxQuantity: () => Promise<AsyncIterator<Int>>;
  description: () => Promise<AsyncIterator<String>>;
}

export interface AggregateProductConfiguration {
  count: Int;
}

export interface AggregateProductConfigurationPromise
  extends Promise<AggregateProductConfiguration>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateProductConfigurationSubscription
  extends Promise<AsyncIterator<AggregateProductConfiguration>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ImageEdge {
  node: Image;
  cursor: String;
}

export interface ImageEdgePromise extends Promise<ImageEdge>, Fragmentable {
  node: <T = ImagePromise>() => T;
  cursor: () => Promise<String>;
}

export interface ImageEdgeSubscription
  extends Promise<AsyncIterator<ImageEdge>>,
    Fragmentable {
  node: <T = ImageSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductEdge {
  node: Product;
  cursor: String;
}

export interface ProductEdgePromise extends Promise<ProductEdge>, Fragmentable {
  node: <T = ProductPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductEdgeSubscription
  extends Promise<AsyncIterator<ProductEdge>>,
    Fragmentable {
  node: <T = ProductSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface ProductConfigurationSubscriptionPayload {
  mutation: MutationType;
  node: ProductConfiguration;
  updatedFields: String[];
  previousValues: ProductConfigurationPreviousValues;
}

export interface ProductConfigurationSubscriptionPayloadPromise
  extends Promise<ProductConfigurationSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductConfigurationPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductConfigurationPreviousValuesPromise>() => T;
}

export interface ProductConfigurationSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductConfigurationSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductConfigurationSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductConfigurationPreviousValuesSubscription>() => T;
}

export interface PriceConnection {
  pageInfo: PageInfo;
  edges: PriceEdge[];
}

export interface PriceConnectionPromise
  extends Promise<PriceConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<PriceEdge>>() => T;
  aggregate: <T = AggregatePricePromise>() => T;
}

export interface PriceConnectionSubscription
  extends Promise<AsyncIterator<PriceConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <T = Promise<AsyncIterator<PriceEdgeSubscription>>>() => T;
  aggregate: <T = AggregatePriceSubscription>() => T;
}

export interface ProductConfigurationPreviousValues {
  id: ID_Output;
  seqId: Int;
  attr: String;
  weight?: Int;
  capacity?: Int;
}

export interface ProductConfigurationPreviousValuesPromise
  extends Promise<ProductConfigurationPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  seqId: () => Promise<Int>;
  attr: () => Promise<String>;
  weight: () => Promise<Int>;
  capacity: () => Promise<Int>;
}

export interface ProductConfigurationPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductConfigurationPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  seqId: () => Promise<AsyncIterator<Int>>;
  attr: () => Promise<AsyncIterator<String>>;
  weight: () => Promise<AsyncIterator<Int>>;
  capacity: () => Promise<AsyncIterator<Int>>;
}

export interface ToppingOrder {
  id: ID_Output;
  createdAt: DateTimeOutput;
  quantity?: Int;
}

export interface ToppingOrderPromise
  extends Promise<ToppingOrder>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  topping: <T = ToppingPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  quantity: () => Promise<Int>;
}

export interface ToppingOrderSubscription
  extends Promise<AsyncIterator<ToppingOrder>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  topping: <T = ToppingSubscription>() => T;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  quantity: () => Promise<AsyncIterator<Int>>;
}

export interface ToppingOrderNullablePromise
  extends Promise<ToppingOrder | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  topping: <T = ToppingPromise>() => T;
  createdAt: () => Promise<DateTimeOutput>;
  quantity: () => Promise<Int>;
}

export interface AggregateImage {
  count: Int;
}

export interface AggregateImagePromise
  extends Promise<AggregateImage>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateImageSubscription
  extends Promise<AsyncIterator<AggregateImage>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface AggregateTopping {
  count: Int;
}

export interface AggregateToppingPromise
  extends Promise<AggregateTopping>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregateToppingSubscription
  extends Promise<AsyncIterator<AggregateTopping>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductConfigurationConnection {
  pageInfo: PageInfo;
  edges: ProductConfigurationEdge[];
}

export interface ProductConfigurationConnectionPromise
  extends Promise<ProductConfigurationConnection>,
    Fragmentable {
  pageInfo: <T = PageInfoPromise>() => T;
  edges: <T = FragmentableArray<ProductConfigurationEdge>>() => T;
  aggregate: <T = AggregateProductConfigurationPromise>() => T;
}

export interface ProductConfigurationConnectionSubscription
  extends Promise<AsyncIterator<ProductConfigurationConnection>>,
    Fragmentable {
  pageInfo: <T = PageInfoSubscription>() => T;
  edges: <
    T = Promise<AsyncIterator<ProductConfigurationEdgeSubscription>>
  >() => T;
  aggregate: <T = AggregateProductConfigurationSubscription>() => T;
}

export interface ToppingSubscriptionPayload {
  mutation: MutationType;
  node: Topping;
  updatedFields: String[];
  previousValues: ToppingPreviousValues;
}

export interface ToppingSubscriptionPayloadPromise
  extends Promise<ToppingSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ToppingPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ToppingPreviousValuesPromise>() => T;
}

export interface ToppingSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ToppingSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ToppingSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ToppingPreviousValuesSubscription>() => T;
}

export interface Order {
  id: ID_Output;
  email: String;
  phone: String;
  name: String;
  time?: DateTimeOutput;
  address1: String;
  address2: String;
  payment: String;
  createdAt: DateTimeOutput;
  updatedAt: DateTimeOutput;
}

export interface OrderPromise extends Promise<Order>, Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  products: <T = FragmentableArray<ProductOrder>>(args?: {
    where?: ProductOrderWhereInput;
    orderBy?: ProductOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  time: () => Promise<DateTimeOutput>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  payment: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface OrderSubscription
  extends Promise<AsyncIterator<Order>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  user: <T = UserSubscription>() => T;
  products: <T = Promise<AsyncIterator<ProductOrderSubscription>>>(args?: {
    where?: ProductOrderWhereInput;
    orderBy?: ProductOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<AsyncIterator<String>>;
  phone: () => Promise<AsyncIterator<String>>;
  name: () => Promise<AsyncIterator<String>>;
  time: () => Promise<AsyncIterator<DateTimeOutput>>;
  address1: () => Promise<AsyncIterator<String>>;
  address2: () => Promise<AsyncIterator<String>>;
  payment: () => Promise<AsyncIterator<String>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
  updatedAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface OrderNullablePromise
  extends Promise<Order | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  user: <T = UserPromise>() => T;
  products: <T = FragmentableArray<ProductOrder>>(args?: {
    where?: ProductOrderWhereInput;
    orderBy?: ProductOrderOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  email: () => Promise<String>;
  phone: () => Promise<String>;
  name: () => Promise<String>;
  time: () => Promise<DateTimeOutput>;
  address1: () => Promise<String>;
  address2: () => Promise<String>;
  payment: () => Promise<String>;
  createdAt: () => Promise<DateTimeOutput>;
  updatedAt: () => Promise<DateTimeOutput>;
}

export interface ProductOrderPreviousValues {
  id: ID_Output;
  quantity: Int;
  createdAt: DateTimeOutput;
}

export interface ProductOrderPreviousValuesPromise
  extends Promise<ProductOrderPreviousValues>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  quantity: () => Promise<Int>;
  createdAt: () => Promise<DateTimeOutput>;
}

export interface ProductOrderPreviousValuesSubscription
  extends Promise<AsyncIterator<ProductOrderPreviousValues>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  quantity: () => Promise<AsyncIterator<Int>>;
  createdAt: () => Promise<AsyncIterator<DateTimeOutput>>;
}

export interface ProductOrderSubscriptionPayload {
  mutation: MutationType;
  node: ProductOrder;
  updatedFields: String[];
  previousValues: ProductOrderPreviousValues;
}

export interface ProductOrderSubscriptionPayloadPromise
  extends Promise<ProductOrderSubscriptionPayload>,
    Fragmentable {
  mutation: () => Promise<MutationType>;
  node: <T = ProductOrderPromise>() => T;
  updatedFields: () => Promise<String[]>;
  previousValues: <T = ProductOrderPreviousValuesPromise>() => T;
}

export interface ProductOrderSubscriptionPayloadSubscription
  extends Promise<AsyncIterator<ProductOrderSubscriptionPayload>>,
    Fragmentable {
  mutation: () => Promise<AsyncIterator<MutationType>>;
  node: <T = ProductOrderSubscription>() => T;
  updatedFields: () => Promise<AsyncIterator<String[]>>;
  previousValues: <T = ProductOrderPreviousValuesSubscription>() => T;
}

export interface AggregatePrice {
  count: Int;
}

export interface AggregatePricePromise
  extends Promise<AggregatePrice>,
    Fragmentable {
  count: () => Promise<Int>;
}

export interface AggregatePriceSubscription
  extends Promise<AsyncIterator<AggregatePrice>>,
    Fragmentable {
  count: () => Promise<AsyncIterator<Int>>;
}

export interface ProductOrderEdge {
  node: ProductOrder;
  cursor: String;
}

export interface ProductOrderEdgePromise
  extends Promise<ProductOrderEdge>,
    Fragmentable {
  node: <T = ProductOrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface ProductOrderEdgeSubscription
  extends Promise<AsyncIterator<ProductOrderEdge>>,
    Fragmentable {
  node: <T = ProductOrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

export interface Topping {
  id: ID_Output;
  name: String;
  description: String;
  maxQuantity?: Int;
}

export interface ToppingPromise extends Promise<Topping>, Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  prices: <T = FragmentableArray<Price>>(args?: {
    where?: PriceWhereInput;
    orderBy?: PriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  image: <T = ImagePromise>() => T;
  description: () => Promise<String>;
  maxQuantity: () => Promise<Int>;
}

export interface ToppingSubscription
  extends Promise<AsyncIterator<Topping>>,
    Fragmentable {
  id: () => Promise<AsyncIterator<ID_Output>>;
  name: () => Promise<AsyncIterator<String>>;
  prices: <T = Promise<AsyncIterator<PriceSubscription>>>(args?: {
    where?: PriceWhereInput;
    orderBy?: PriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  image: <T = ImageSubscription>() => T;
  description: () => Promise<AsyncIterator<String>>;
  maxQuantity: () => Promise<AsyncIterator<Int>>;
}

export interface ToppingNullablePromise
  extends Promise<Topping | null>,
    Fragmentable {
  id: () => Promise<ID_Output>;
  name: () => Promise<String>;
  prices: <T = FragmentableArray<Price>>(args?: {
    where?: PriceWhereInput;
    orderBy?: PriceOrderByInput;
    skip?: Int;
    after?: String;
    before?: String;
    first?: Int;
    last?: Int;
  }) => T;
  image: <T = ImagePromise>() => T;
  description: () => Promise<String>;
  maxQuantity: () => Promise<Int>;
}

export interface OrderEdge {
  node: Order;
  cursor: String;
}

export interface OrderEdgePromise extends Promise<OrderEdge>, Fragmentable {
  node: <T = OrderPromise>() => T;
  cursor: () => Promise<String>;
}

export interface OrderEdgeSubscription
  extends Promise<AsyncIterator<OrderEdge>>,
    Fragmentable {
  node: <T = OrderSubscription>() => T;
  cursor: () => Promise<AsyncIterator<String>>;
}

/*
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
*/
export type ID_Input = string | number;
export type ID_Output = string;

/*
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
*/
export type String = string;

/*
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
*/
export type Int = number;

/*
DateTime scalar input type, allowing Date
*/
export type DateTimeInput = Date | string;

/*
DateTime scalar output type, which is always a string
*/
export type DateTimeOutput = string;

export type Long = string;

/*
The `Boolean` scalar type represents `true` or `false`.
*/
export type Boolean = boolean;

/*
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
*/
export type Float = number;

/**
 * Model Metadata
 */

export const models: Model[] = [
  {
    name: "User",
    embedded: false
  },
  {
    name: "Order",
    embedded: false
  },
  {
    name: "ToppingOrder",
    embedded: false
  },
  {
    name: "ProductOrder",
    embedded: false
  },
  {
    name: "Currency",
    embedded: false
  },
  {
    name: "Category",
    embedded: false
  },
  {
    name: "ImageSize",
    embedded: false
  },
  {
    name: "Price",
    embedded: false
  },
  {
    name: "ProductConfiguration",
    embedded: false
  },
  {
    name: "Product",
    embedded: false
  },
  {
    name: "Topping",
    embedded: false
  },
  {
    name: "Image",
    embedded: false
  }
];

/**
 * Type Defs
 */

export const prisma: Prisma;
