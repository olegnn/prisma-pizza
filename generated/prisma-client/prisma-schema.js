module.exports = {
        typeDefs: // Code generated by Prisma (prisma@1.34.10). DO NOT EDIT.
  // Please don't change this file manually but run `prisma generate` to update it.
  // For more information, please read the docs: https://www.prisma.io/docs/prisma-client/

/* GraphQL */ `type AggregateImage {
  count: Int!
}

type AggregateOrder {
  count: Int!
}

type AggregatePrice {
  count: Int!
}

type AggregateProduct {
  count: Int!
}

type AggregateProductConfiguration {
  count: Int!
}

type AggregateProductOrder {
  count: Int!
}

type AggregateTopping {
  count: Int!
}

type AggregateToppingOrder {
  count: Int!
}

type AggregateUser {
  count: Int!
}

type BatchPayload {
  count: Long!
}

enum Category {
  Pizza
  Drink
  Dessert
  Soup
}

enum Currency {
  GBP
  EUR
  USD
  RUB
}

scalar DateTime

type Image {
  id: ID!
  size: ImageSize!
  source: String!
  alt: String
}

type ImageConnection {
  pageInfo: PageInfo!
  edges: [ImageEdge]!
  aggregate: AggregateImage!
}

input ImageCreateInput {
  id: ID
  size: ImageSize!
  source: String!
  alt: String
}

input ImageCreateManyInput {
  create: [ImageCreateInput!]
  connect: [ImageWhereUniqueInput!]
}

input ImageCreateOneInput {
  create: ImageCreateInput
  connect: ImageWhereUniqueInput
}

type ImageEdge {
  node: Image!
  cursor: String!
}

enum ImageOrderByInput {
  id_ASC
  id_DESC
  size_ASC
  size_DESC
  source_ASC
  source_DESC
  alt_ASC
  alt_DESC
}

type ImagePreviousValues {
  id: ID!
  size: ImageSize!
  source: String!
  alt: String
}

input ImageScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  size: ImageSize
  size_not: ImageSize
  size_in: [ImageSize!]
  size_not_in: [ImageSize!]
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  alt: String
  alt_not: String
  alt_in: [String!]
  alt_not_in: [String!]
  alt_lt: String
  alt_lte: String
  alt_gt: String
  alt_gte: String
  alt_contains: String
  alt_not_contains: String
  alt_starts_with: String
  alt_not_starts_with: String
  alt_ends_with: String
  alt_not_ends_with: String
  AND: [ImageScalarWhereInput!]
  OR: [ImageScalarWhereInput!]
  NOT: [ImageScalarWhereInput!]
}

enum ImageSize {
  Large
  Medium
  Small
}

type ImageSubscriptionPayload {
  mutation: MutationType!
  node: Image
  updatedFields: [String!]
  previousValues: ImagePreviousValues
}

input ImageSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ImageWhereInput
  AND: [ImageSubscriptionWhereInput!]
  OR: [ImageSubscriptionWhereInput!]
  NOT: [ImageSubscriptionWhereInput!]
}

input ImageUpdateDataInput {
  size: ImageSize
  source: String
  alt: String
}

input ImageUpdateInput {
  size: ImageSize
  source: String
  alt: String
}

input ImageUpdateManyDataInput {
  size: ImageSize
  source: String
  alt: String
}

input ImageUpdateManyInput {
  create: [ImageCreateInput!]
  update: [ImageUpdateWithWhereUniqueNestedInput!]
  upsert: [ImageUpsertWithWhereUniqueNestedInput!]
  delete: [ImageWhereUniqueInput!]
  connect: [ImageWhereUniqueInput!]
  set: [ImageWhereUniqueInput!]
  disconnect: [ImageWhereUniqueInput!]
  deleteMany: [ImageScalarWhereInput!]
  updateMany: [ImageUpdateManyWithWhereNestedInput!]
}

input ImageUpdateManyMutationInput {
  size: ImageSize
  source: String
  alt: String
}

input ImageUpdateManyWithWhereNestedInput {
  where: ImageScalarWhereInput!
  data: ImageUpdateManyDataInput!
}

input ImageUpdateOneRequiredInput {
  create: ImageCreateInput
  update: ImageUpdateDataInput
  upsert: ImageUpsertNestedInput
  connect: ImageWhereUniqueInput
}

input ImageUpdateWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput!
  data: ImageUpdateDataInput!
}

input ImageUpsertNestedInput {
  update: ImageUpdateDataInput!
  create: ImageCreateInput!
}

input ImageUpsertWithWhereUniqueNestedInput {
  where: ImageWhereUniqueInput!
  update: ImageUpdateDataInput!
  create: ImageCreateInput!
}

input ImageWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  size: ImageSize
  size_not: ImageSize
  size_in: [ImageSize!]
  size_not_in: [ImageSize!]
  source: String
  source_not: String
  source_in: [String!]
  source_not_in: [String!]
  source_lt: String
  source_lte: String
  source_gt: String
  source_gte: String
  source_contains: String
  source_not_contains: String
  source_starts_with: String
  source_not_starts_with: String
  source_ends_with: String
  source_not_ends_with: String
  alt: String
  alt_not: String
  alt_in: [String!]
  alt_not_in: [String!]
  alt_lt: String
  alt_lte: String
  alt_gt: String
  alt_gte: String
  alt_contains: String
  alt_not_contains: String
  alt_starts_with: String
  alt_not_starts_with: String
  alt_ends_with: String
  alt_not_ends_with: String
  AND: [ImageWhereInput!]
  OR: [ImageWhereInput!]
  NOT: [ImageWhereInput!]
}

input ImageWhereUniqueInput {
  id: ID
}

scalar Long

type Mutation {
  createImage(data: ImageCreateInput!): Image!
  updateImage(data: ImageUpdateInput!, where: ImageWhereUniqueInput!): Image
  updateManyImages(data: ImageUpdateManyMutationInput!, where: ImageWhereInput): BatchPayload!
  upsertImage(where: ImageWhereUniqueInput!, create: ImageCreateInput!, update: ImageUpdateInput!): Image!
  deleteImage(where: ImageWhereUniqueInput!): Image
  deleteManyImages(where: ImageWhereInput): BatchPayload!
  createOrder(data: OrderCreateInput!): Order!
  updateOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateManyOrders(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): BatchPayload!
  upsertOrder(where: OrderWhereUniqueInput!, create: OrderCreateInput!, update: OrderUpdateInput!): Order!
  deleteOrder(where: OrderWhereUniqueInput!): Order
  deleteManyOrders(where: OrderWhereInput): BatchPayload!
  createPrice(data: PriceCreateInput!): Price!
  updatePrice(data: PriceUpdateInput!, where: PriceWhereUniqueInput!): Price
  updateManyPrices(data: PriceUpdateManyMutationInput!, where: PriceWhereInput): BatchPayload!
  upsertPrice(where: PriceWhereUniqueInput!, create: PriceCreateInput!, update: PriceUpdateInput!): Price!
  deletePrice(where: PriceWhereUniqueInput!): Price
  deleteManyPrices(where: PriceWhereInput): BatchPayload!
  createProduct(data: ProductCreateInput!): Product!
  updateProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateManyProducts(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): BatchPayload!
  upsertProduct(where: ProductWhereUniqueInput!, create: ProductCreateInput!, update: ProductUpdateInput!): Product!
  deleteProduct(where: ProductWhereUniqueInput!): Product
  deleteManyProducts(where: ProductWhereInput): BatchPayload!
  createProductConfiguration(data: ProductConfigurationCreateInput!): ProductConfiguration!
  updateProductConfiguration(data: ProductConfigurationUpdateInput!, where: ProductConfigurationWhereUniqueInput!): ProductConfiguration
  updateManyProductConfigurations(data: ProductConfigurationUpdateManyMutationInput!, where: ProductConfigurationWhereInput): BatchPayload!
  upsertProductConfiguration(where: ProductConfigurationWhereUniqueInput!, create: ProductConfigurationCreateInput!, update: ProductConfigurationUpdateInput!): ProductConfiguration!
  deleteProductConfiguration(where: ProductConfigurationWhereUniqueInput!): ProductConfiguration
  deleteManyProductConfigurations(where: ProductConfigurationWhereInput): BatchPayload!
  createProductOrder(data: ProductOrderCreateInput!): ProductOrder!
  updateProductOrder(data: ProductOrderUpdateInput!, where: ProductOrderWhereUniqueInput!): ProductOrder
  updateManyProductOrders(data: ProductOrderUpdateManyMutationInput!, where: ProductOrderWhereInput): BatchPayload!
  upsertProductOrder(where: ProductOrderWhereUniqueInput!, create: ProductOrderCreateInput!, update: ProductOrderUpdateInput!): ProductOrder!
  deleteProductOrder(where: ProductOrderWhereUniqueInput!): ProductOrder
  deleteManyProductOrders(where: ProductOrderWhereInput): BatchPayload!
  createTopping(data: ToppingCreateInput!): Topping!
  updateTopping(data: ToppingUpdateInput!, where: ToppingWhereUniqueInput!): Topping
  updateManyToppings(data: ToppingUpdateManyMutationInput!, where: ToppingWhereInput): BatchPayload!
  upsertTopping(where: ToppingWhereUniqueInput!, create: ToppingCreateInput!, update: ToppingUpdateInput!): Topping!
  deleteTopping(where: ToppingWhereUniqueInput!): Topping
  deleteManyToppings(where: ToppingWhereInput): BatchPayload!
  createToppingOrder(data: ToppingOrderCreateInput!): ToppingOrder!
  updateToppingOrder(data: ToppingOrderUpdateInput!, where: ToppingOrderWhereUniqueInput!): ToppingOrder
  updateManyToppingOrders(data: ToppingOrderUpdateManyMutationInput!, where: ToppingOrderWhereInput): BatchPayload!
  upsertToppingOrder(where: ToppingOrderWhereUniqueInput!, create: ToppingOrderCreateInput!, update: ToppingOrderUpdateInput!): ToppingOrder!
  deleteToppingOrder(where: ToppingOrderWhereUniqueInput!): ToppingOrder
  deleteManyToppingOrders(where: ToppingOrderWhereInput): BatchPayload!
  createUser(data: UserCreateInput!): User!
  updateUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateManyUsers(data: UserUpdateManyMutationInput!, where: UserWhereInput): BatchPayload!
  upsertUser(where: UserWhereUniqueInput!, create: UserCreateInput!, update: UserUpdateInput!): User!
  deleteUser(where: UserWhereUniqueInput!): User
  deleteManyUsers(where: UserWhereInput): BatchPayload!
}

enum MutationType {
  CREATED
  UPDATED
  DELETED
}

interface Node {
  id: ID!
}

type Order {
  id: ID!
  user: User
  products(where: ProductOrderWhereInput, orderBy: ProductOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductOrder!]
  email: String!
  phone: String!
  name: String!
  time: DateTime
  address1: String!
  address2: String!
  payment: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

type OrderConnection {
  pageInfo: PageInfo!
  edges: [OrderEdge]!
  aggregate: AggregateOrder!
}

input OrderCreateInput {
  id: ID
  user: UserCreateOneWithoutOrdersInput
  products: ProductOrderCreateManyInput
  email: String!
  phone: String!
  name: String!
  time: DateTime
  address1: String!
  address2: String!
  payment: String!
}

input OrderCreateManyWithoutUserInput {
  create: [OrderCreateWithoutUserInput!]
  connect: [OrderWhereUniqueInput!]
}

input OrderCreateWithoutUserInput {
  id: ID
  products: ProductOrderCreateManyInput
  email: String!
  phone: String!
  name: String!
  time: DateTime
  address1: String!
  address2: String!
  payment: String!
}

type OrderEdge {
  node: Order!
  cursor: String!
}

enum OrderOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  phone_ASC
  phone_DESC
  name_ASC
  name_DESC
  time_ASC
  time_DESC
  address1_ASC
  address1_DESC
  address2_ASC
  address2_DESC
  payment_ASC
  payment_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type OrderPreviousValues {
  id: ID!
  email: String!
  phone: String!
  name: String!
  time: DateTime
  address1: String!
  address2: String!
  payment: String!
  createdAt: DateTime!
  updatedAt: DateTime!
}

input OrderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  address1: String
  address1_not: String
  address1_in: [String!]
  address1_not_in: [String!]
  address1_lt: String
  address1_lte: String
  address1_gt: String
  address1_gte: String
  address1_contains: String
  address1_not_contains: String
  address1_starts_with: String
  address1_not_starts_with: String
  address1_ends_with: String
  address1_not_ends_with: String
  address2: String
  address2_not: String
  address2_in: [String!]
  address2_not_in: [String!]
  address2_lt: String
  address2_lte: String
  address2_gt: String
  address2_gte: String
  address2_contains: String
  address2_not_contains: String
  address2_starts_with: String
  address2_not_starts_with: String
  address2_ends_with: String
  address2_not_ends_with: String
  payment: String
  payment_not: String
  payment_in: [String!]
  payment_not_in: [String!]
  payment_lt: String
  payment_lte: String
  payment_gt: String
  payment_gte: String
  payment_contains: String
  payment_not_contains: String
  payment_starts_with: String
  payment_not_starts_with: String
  payment_ends_with: String
  payment_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  NOT: [OrderScalarWhereInput!]
}

type OrderSubscriptionPayload {
  mutation: MutationType!
  node: Order
  updatedFields: [String!]
  previousValues: OrderPreviousValues
}

input OrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: OrderWhereInput
  AND: [OrderSubscriptionWhereInput!]
  OR: [OrderSubscriptionWhereInput!]
  NOT: [OrderSubscriptionWhereInput!]
}

input OrderUpdateInput {
  user: UserUpdateOneWithoutOrdersInput
  products: ProductOrderUpdateManyInput
  email: String
  phone: String
  name: String
  time: DateTime
  address1: String
  address2: String
  payment: String
}

input OrderUpdateManyDataInput {
  email: String
  phone: String
  name: String
  time: DateTime
  address1: String
  address2: String
  payment: String
}

input OrderUpdateManyMutationInput {
  email: String
  phone: String
  name: String
  time: DateTime
  address1: String
  address2: String
  payment: String
}

input OrderUpdateManyWithoutUserInput {
  create: [OrderCreateWithoutUserInput!]
  delete: [OrderWhereUniqueInput!]
  connect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  disconnect: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutUserInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutUserInput!]
  deleteMany: [OrderScalarWhereInput!]
  updateMany: [OrderUpdateManyWithWhereNestedInput!]
}

input OrderUpdateManyWithWhereNestedInput {
  where: OrderScalarWhereInput!
  data: OrderUpdateManyDataInput!
}

input OrderUpdateWithoutUserDataInput {
  products: ProductOrderUpdateManyInput
  email: String
  phone: String
  name: String
  time: DateTime
  address1: String
  address2: String
  payment: String
}

input OrderUpdateWithWhereUniqueWithoutUserInput {
  where: OrderWhereUniqueInput!
  data: OrderUpdateWithoutUserDataInput!
}

input OrderUpsertWithWhereUniqueWithoutUserInput {
  where: OrderWhereUniqueInput!
  update: OrderUpdateWithoutUserDataInput!
  create: OrderCreateWithoutUserInput!
}

input OrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  user: UserWhereInput
  products_every: ProductOrderWhereInput
  products_some: ProductOrderWhereInput
  products_none: ProductOrderWhereInput
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  time: DateTime
  time_not: DateTime
  time_in: [DateTime!]
  time_not_in: [DateTime!]
  time_lt: DateTime
  time_lte: DateTime
  time_gt: DateTime
  time_gte: DateTime
  address1: String
  address1_not: String
  address1_in: [String!]
  address1_not_in: [String!]
  address1_lt: String
  address1_lte: String
  address1_gt: String
  address1_gte: String
  address1_contains: String
  address1_not_contains: String
  address1_starts_with: String
  address1_not_starts_with: String
  address1_ends_with: String
  address1_not_ends_with: String
  address2: String
  address2_not: String
  address2_in: [String!]
  address2_not_in: [String!]
  address2_lt: String
  address2_lte: String
  address2_gt: String
  address2_gte: String
  address2_contains: String
  address2_not_contains: String
  address2_starts_with: String
  address2_not_starts_with: String
  address2_ends_with: String
  address2_not_ends_with: String
  payment: String
  payment_not: String
  payment_in: [String!]
  payment_not_in: [String!]
  payment_lt: String
  payment_lte: String
  payment_gt: String
  payment_gte: String
  payment_contains: String
  payment_not_contains: String
  payment_starts_with: String
  payment_not_starts_with: String
  payment_ends_with: String
  payment_not_ends_with: String
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
}

input OrderWhereUniqueInput {
  id: ID
}

type PageInfo {
  hasNextPage: Boolean!
  hasPreviousPage: Boolean!
  startCursor: String
  endCursor: String
}

type Price {
  id: ID!
  currency: Currency!
  amount: Int!
}

type PriceConnection {
  pageInfo: PageInfo!
  edges: [PriceEdge]!
  aggregate: AggregatePrice!
}

input PriceCreateInput {
  id: ID
  currency: Currency!
  amount: Int!
}

input PriceCreateManyInput {
  create: [PriceCreateInput!]
  connect: [PriceWhereUniqueInput!]
}

type PriceEdge {
  node: Price!
  cursor: String!
}

enum PriceOrderByInput {
  id_ASC
  id_DESC
  currency_ASC
  currency_DESC
  amount_ASC
  amount_DESC
}

type PricePreviousValues {
  id: ID!
  currency: Currency!
  amount: Int!
}

input PriceScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  currency: Currency
  currency_not: Currency
  currency_in: [Currency!]
  currency_not_in: [Currency!]
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  AND: [PriceScalarWhereInput!]
  OR: [PriceScalarWhereInput!]
  NOT: [PriceScalarWhereInput!]
}

type PriceSubscriptionPayload {
  mutation: MutationType!
  node: Price
  updatedFields: [String!]
  previousValues: PricePreviousValues
}

input PriceSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: PriceWhereInput
  AND: [PriceSubscriptionWhereInput!]
  OR: [PriceSubscriptionWhereInput!]
  NOT: [PriceSubscriptionWhereInput!]
}

input PriceUpdateDataInput {
  currency: Currency
  amount: Int
}

input PriceUpdateInput {
  currency: Currency
  amount: Int
}

input PriceUpdateManyDataInput {
  currency: Currency
  amount: Int
}

input PriceUpdateManyInput {
  create: [PriceCreateInput!]
  update: [PriceUpdateWithWhereUniqueNestedInput!]
  upsert: [PriceUpsertWithWhereUniqueNestedInput!]
  delete: [PriceWhereUniqueInput!]
  connect: [PriceWhereUniqueInput!]
  set: [PriceWhereUniqueInput!]
  disconnect: [PriceWhereUniqueInput!]
  deleteMany: [PriceScalarWhereInput!]
  updateMany: [PriceUpdateManyWithWhereNestedInput!]
}

input PriceUpdateManyMutationInput {
  currency: Currency
  amount: Int
}

input PriceUpdateManyWithWhereNestedInput {
  where: PriceScalarWhereInput!
  data: PriceUpdateManyDataInput!
}

input PriceUpdateWithWhereUniqueNestedInput {
  where: PriceWhereUniqueInput!
  data: PriceUpdateDataInput!
}

input PriceUpsertWithWhereUniqueNestedInput {
  where: PriceWhereUniqueInput!
  update: PriceUpdateDataInput!
  create: PriceCreateInput!
}

input PriceWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  currency: Currency
  currency_not: Currency
  currency_in: [Currency!]
  currency_not_in: [Currency!]
  amount: Int
  amount_not: Int
  amount_in: [Int!]
  amount_not_in: [Int!]
  amount_lt: Int
  amount_lte: Int
  amount_gt: Int
  amount_gte: Int
  AND: [PriceWhereInput!]
  OR: [PriceWhereInput!]
  NOT: [PriceWhereInput!]
}

input PriceWhereUniqueInput {
  id: ID
}

type Product {
  id: ID!
  name: String!
  category: Category!
  configurations(where: ProductConfigurationWhereInput, orderBy: ProductConfigurationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductConfiguration!]
  toppings(where: ToppingWhereInput, orderBy: ToppingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Topping!]
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image!]
  createdAt: DateTime!
  popularity: Float
  maxQuantity: Int
  description: String
}

type ProductConfiguration {
  id: ID!
  seqId: Int!
  attr: String!
  prices(where: PriceWhereInput, orderBy: PriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Price!]
  weight: Int
  capacity: Int
}

type ProductConfigurationConnection {
  pageInfo: PageInfo!
  edges: [ProductConfigurationEdge]!
  aggregate: AggregateProductConfiguration!
}

input ProductConfigurationCreateInput {
  id: ID
  seqId: Int!
  attr: String!
  prices: PriceCreateManyInput
  weight: Int
  capacity: Int
}

input ProductConfigurationCreateManyInput {
  create: [ProductConfigurationCreateInput!]
  connect: [ProductConfigurationWhereUniqueInput!]
}

input ProductConfigurationCreateOneInput {
  create: ProductConfigurationCreateInput
  connect: ProductConfigurationWhereUniqueInput
}

type ProductConfigurationEdge {
  node: ProductConfiguration!
  cursor: String!
}

enum ProductConfigurationOrderByInput {
  id_ASC
  id_DESC
  seqId_ASC
  seqId_DESC
  attr_ASC
  attr_DESC
  weight_ASC
  weight_DESC
  capacity_ASC
  capacity_DESC
}

type ProductConfigurationPreviousValues {
  id: ID!
  seqId: Int!
  attr: String!
  weight: Int
  capacity: Int
}

input ProductConfigurationScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  seqId: Int
  seqId_not: Int
  seqId_in: [Int!]
  seqId_not_in: [Int!]
  seqId_lt: Int
  seqId_lte: Int
  seqId_gt: Int
  seqId_gte: Int
  attr: String
  attr_not: String
  attr_in: [String!]
  attr_not_in: [String!]
  attr_lt: String
  attr_lte: String
  attr_gt: String
  attr_gte: String
  attr_contains: String
  attr_not_contains: String
  attr_starts_with: String
  attr_not_starts_with: String
  attr_ends_with: String
  attr_not_ends_with: String
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  capacity: Int
  capacity_not: Int
  capacity_in: [Int!]
  capacity_not_in: [Int!]
  capacity_lt: Int
  capacity_lte: Int
  capacity_gt: Int
  capacity_gte: Int
  AND: [ProductConfigurationScalarWhereInput!]
  OR: [ProductConfigurationScalarWhereInput!]
  NOT: [ProductConfigurationScalarWhereInput!]
}

type ProductConfigurationSubscriptionPayload {
  mutation: MutationType!
  node: ProductConfiguration
  updatedFields: [String!]
  previousValues: ProductConfigurationPreviousValues
}

input ProductConfigurationSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductConfigurationWhereInput
  AND: [ProductConfigurationSubscriptionWhereInput!]
  OR: [ProductConfigurationSubscriptionWhereInput!]
  NOT: [ProductConfigurationSubscriptionWhereInput!]
}

input ProductConfigurationUpdateDataInput {
  seqId: Int
  attr: String
  prices: PriceUpdateManyInput
  weight: Int
  capacity: Int
}

input ProductConfigurationUpdateInput {
  seqId: Int
  attr: String
  prices: PriceUpdateManyInput
  weight: Int
  capacity: Int
}

input ProductConfigurationUpdateManyDataInput {
  seqId: Int
  attr: String
  weight: Int
  capacity: Int
}

input ProductConfigurationUpdateManyInput {
  create: [ProductConfigurationCreateInput!]
  update: [ProductConfigurationUpdateWithWhereUniqueNestedInput!]
  upsert: [ProductConfigurationUpsertWithWhereUniqueNestedInput!]
  delete: [ProductConfigurationWhereUniqueInput!]
  connect: [ProductConfigurationWhereUniqueInput!]
  set: [ProductConfigurationWhereUniqueInput!]
  disconnect: [ProductConfigurationWhereUniqueInput!]
  deleteMany: [ProductConfigurationScalarWhereInput!]
  updateMany: [ProductConfigurationUpdateManyWithWhereNestedInput!]
}

input ProductConfigurationUpdateManyMutationInput {
  seqId: Int
  attr: String
  weight: Int
  capacity: Int
}

input ProductConfigurationUpdateManyWithWhereNestedInput {
  where: ProductConfigurationScalarWhereInput!
  data: ProductConfigurationUpdateManyDataInput!
}

input ProductConfigurationUpdateOneInput {
  create: ProductConfigurationCreateInput
  update: ProductConfigurationUpdateDataInput
  upsert: ProductConfigurationUpsertNestedInput
  delete: Boolean
  disconnect: Boolean
  connect: ProductConfigurationWhereUniqueInput
}

input ProductConfigurationUpdateWithWhereUniqueNestedInput {
  where: ProductConfigurationWhereUniqueInput!
  data: ProductConfigurationUpdateDataInput!
}

input ProductConfigurationUpsertNestedInput {
  update: ProductConfigurationUpdateDataInput!
  create: ProductConfigurationCreateInput!
}

input ProductConfigurationUpsertWithWhereUniqueNestedInput {
  where: ProductConfigurationWhereUniqueInput!
  update: ProductConfigurationUpdateDataInput!
  create: ProductConfigurationCreateInput!
}

input ProductConfigurationWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  seqId: Int
  seqId_not: Int
  seqId_in: [Int!]
  seqId_not_in: [Int!]
  seqId_lt: Int
  seqId_lte: Int
  seqId_gt: Int
  seqId_gte: Int
  attr: String
  attr_not: String
  attr_in: [String!]
  attr_not_in: [String!]
  attr_lt: String
  attr_lte: String
  attr_gt: String
  attr_gte: String
  attr_contains: String
  attr_not_contains: String
  attr_starts_with: String
  attr_not_starts_with: String
  attr_ends_with: String
  attr_not_ends_with: String
  prices_every: PriceWhereInput
  prices_some: PriceWhereInput
  prices_none: PriceWhereInput
  weight: Int
  weight_not: Int
  weight_in: [Int!]
  weight_not_in: [Int!]
  weight_lt: Int
  weight_lte: Int
  weight_gt: Int
  weight_gte: Int
  capacity: Int
  capacity_not: Int
  capacity_in: [Int!]
  capacity_not_in: [Int!]
  capacity_lt: Int
  capacity_lte: Int
  capacity_gt: Int
  capacity_gte: Int
  AND: [ProductConfigurationWhereInput!]
  OR: [ProductConfigurationWhereInput!]
  NOT: [ProductConfigurationWhereInput!]
}

input ProductConfigurationWhereUniqueInput {
  id: ID
}

type ProductConnection {
  pageInfo: PageInfo!
  edges: [ProductEdge]!
  aggregate: AggregateProduct!
}

input ProductCreateInput {
  id: ID
  name: String!
  category: Category!
  configurations: ProductConfigurationCreateManyInput
  toppings: ToppingCreateManyInput
  images: ImageCreateManyInput
  popularity: Float
  maxQuantity: Int
  description: String
}

input ProductCreateOneInput {
  create: ProductCreateInput
  connect: ProductWhereUniqueInput
}

type ProductEdge {
  node: Product!
  cursor: String!
}

type ProductOrder {
  id: ID!
  product: Product!
  quantity: Int!
  createdAt: DateTime!
  configuration: ProductConfiguration
  toppings(where: ToppingOrderWhereInput, orderBy: ToppingOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ToppingOrder!]
}

enum ProductOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  category_ASC
  category_DESC
  createdAt_ASC
  createdAt_DESC
  popularity_ASC
  popularity_DESC
  maxQuantity_ASC
  maxQuantity_DESC
  description_ASC
  description_DESC
}

type ProductOrderConnection {
  pageInfo: PageInfo!
  edges: [ProductOrderEdge]!
  aggregate: AggregateProductOrder!
}

input ProductOrderCreateInput {
  id: ID
  product: ProductCreateOneInput!
  quantity: Int!
  configuration: ProductConfigurationCreateOneInput
  toppings: ToppingOrderCreateManyInput
}

input ProductOrderCreateManyInput {
  create: [ProductOrderCreateInput!]
  connect: [ProductOrderWhereUniqueInput!]
}

type ProductOrderEdge {
  node: ProductOrder!
  cursor: String!
}

enum ProductOrderOrderByInput {
  id_ASC
  id_DESC
  quantity_ASC
  quantity_DESC
  createdAt_ASC
  createdAt_DESC
}

type ProductOrderPreviousValues {
  id: ID!
  quantity: Int!
  createdAt: DateTime!
}

input ProductOrderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  AND: [ProductOrderScalarWhereInput!]
  OR: [ProductOrderScalarWhereInput!]
  NOT: [ProductOrderScalarWhereInput!]
}

type ProductOrderSubscriptionPayload {
  mutation: MutationType!
  node: ProductOrder
  updatedFields: [String!]
  previousValues: ProductOrderPreviousValues
}

input ProductOrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductOrderWhereInput
  AND: [ProductOrderSubscriptionWhereInput!]
  OR: [ProductOrderSubscriptionWhereInput!]
  NOT: [ProductOrderSubscriptionWhereInput!]
}

input ProductOrderUpdateDataInput {
  product: ProductUpdateOneRequiredInput
  quantity: Int
  configuration: ProductConfigurationUpdateOneInput
  toppings: ToppingOrderUpdateManyInput
}

input ProductOrderUpdateInput {
  product: ProductUpdateOneRequiredInput
  quantity: Int
  configuration: ProductConfigurationUpdateOneInput
  toppings: ToppingOrderUpdateManyInput
}

input ProductOrderUpdateManyDataInput {
  quantity: Int
}

input ProductOrderUpdateManyInput {
  create: [ProductOrderCreateInput!]
  update: [ProductOrderUpdateWithWhereUniqueNestedInput!]
  upsert: [ProductOrderUpsertWithWhereUniqueNestedInput!]
  delete: [ProductOrderWhereUniqueInput!]
  connect: [ProductOrderWhereUniqueInput!]
  set: [ProductOrderWhereUniqueInput!]
  disconnect: [ProductOrderWhereUniqueInput!]
  deleteMany: [ProductOrderScalarWhereInput!]
  updateMany: [ProductOrderUpdateManyWithWhereNestedInput!]
}

input ProductOrderUpdateManyMutationInput {
  quantity: Int
}

input ProductOrderUpdateManyWithWhereNestedInput {
  where: ProductOrderScalarWhereInput!
  data: ProductOrderUpdateManyDataInput!
}

input ProductOrderUpdateWithWhereUniqueNestedInput {
  where: ProductOrderWhereUniqueInput!
  data: ProductOrderUpdateDataInput!
}

input ProductOrderUpsertWithWhereUniqueNestedInput {
  where: ProductOrderWhereUniqueInput!
  update: ProductOrderUpdateDataInput!
  create: ProductOrderCreateInput!
}

input ProductOrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  product: ProductWhereInput
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  configuration: ProductConfigurationWhereInput
  toppings_every: ToppingOrderWhereInput
  toppings_some: ToppingOrderWhereInput
  toppings_none: ToppingOrderWhereInput
  AND: [ProductOrderWhereInput!]
  OR: [ProductOrderWhereInput!]
  NOT: [ProductOrderWhereInput!]
}

input ProductOrderWhereUniqueInput {
  id: ID
}

type ProductPreviousValues {
  id: ID!
  name: String!
  category: Category!
  createdAt: DateTime!
  popularity: Float
  maxQuantity: Int
  description: String
}

type ProductSubscriptionPayload {
  mutation: MutationType!
  node: Product
  updatedFields: [String!]
  previousValues: ProductPreviousValues
}

input ProductSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ProductWhereInput
  AND: [ProductSubscriptionWhereInput!]
  OR: [ProductSubscriptionWhereInput!]
  NOT: [ProductSubscriptionWhereInput!]
}

input ProductUpdateDataInput {
  name: String
  category: Category
  configurations: ProductConfigurationUpdateManyInput
  toppings: ToppingUpdateManyInput
  images: ImageUpdateManyInput
  popularity: Float
  maxQuantity: Int
  description: String
}

input ProductUpdateInput {
  name: String
  category: Category
  configurations: ProductConfigurationUpdateManyInput
  toppings: ToppingUpdateManyInput
  images: ImageUpdateManyInput
  popularity: Float
  maxQuantity: Int
  description: String
}

input ProductUpdateManyMutationInput {
  name: String
  category: Category
  popularity: Float
  maxQuantity: Int
  description: String
}

input ProductUpdateOneRequiredInput {
  create: ProductCreateInput
  update: ProductUpdateDataInput
  upsert: ProductUpsertNestedInput
  connect: ProductWhereUniqueInput
}

input ProductUpsertNestedInput {
  update: ProductUpdateDataInput!
  create: ProductCreateInput!
}

input ProductWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  category: Category
  category_not: Category
  category_in: [Category!]
  category_not_in: [Category!]
  configurations_every: ProductConfigurationWhereInput
  configurations_some: ProductConfigurationWhereInput
  configurations_none: ProductConfigurationWhereInput
  toppings_every: ToppingWhereInput
  toppings_some: ToppingWhereInput
  toppings_none: ToppingWhereInput
  images_every: ImageWhereInput
  images_some: ImageWhereInput
  images_none: ImageWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  popularity: Float
  popularity_not: Float
  popularity_in: [Float!]
  popularity_not_in: [Float!]
  popularity_lt: Float
  popularity_lte: Float
  popularity_gt: Float
  popularity_gte: Float
  maxQuantity: Int
  maxQuantity_not: Int
  maxQuantity_in: [Int!]
  maxQuantity_not_in: [Int!]
  maxQuantity_lt: Int
  maxQuantity_lte: Int
  maxQuantity_gt: Int
  maxQuantity_gte: Int
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  AND: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
}

input ProductWhereUniqueInput {
  id: ID
}

type Query {
  image(where: ImageWhereUniqueInput!): Image
  images(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Image]!
  imagesConnection(where: ImageWhereInput, orderBy: ImageOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ImageConnection!
  order(where: OrderWhereUniqueInput!): Order
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order]!
  ordersConnection(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): OrderConnection!
  price(where: PriceWhereUniqueInput!): Price
  prices(where: PriceWhereInput, orderBy: PriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Price]!
  pricesConnection(where: PriceWhereInput, orderBy: PriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): PriceConnection!
  product(where: ProductWhereUniqueInput!): Product
  products(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Product]!
  productsConnection(where: ProductWhereInput, orderBy: ProductOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConnection!
  productConfiguration(where: ProductConfigurationWhereUniqueInput!): ProductConfiguration
  productConfigurations(where: ProductConfigurationWhereInput, orderBy: ProductConfigurationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductConfiguration]!
  productConfigurationsConnection(where: ProductConfigurationWhereInput, orderBy: ProductConfigurationOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductConfigurationConnection!
  productOrder(where: ProductOrderWhereUniqueInput!): ProductOrder
  productOrders(where: ProductOrderWhereInput, orderBy: ProductOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ProductOrder]!
  productOrdersConnection(where: ProductOrderWhereInput, orderBy: ProductOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ProductOrderConnection!
  topping(where: ToppingWhereUniqueInput!): Topping
  toppings(where: ToppingWhereInput, orderBy: ToppingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Topping]!
  toppingsConnection(where: ToppingWhereInput, orderBy: ToppingOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ToppingConnection!
  toppingOrder(where: ToppingOrderWhereUniqueInput!): ToppingOrder
  toppingOrders(where: ToppingOrderWhereInput, orderBy: ToppingOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [ToppingOrder]!
  toppingOrdersConnection(where: ToppingOrderWhereInput, orderBy: ToppingOrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): ToppingOrderConnection!
  user(where: UserWhereUniqueInput!): User
  users(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [User]!
  usersConnection(where: UserWhereInput, orderBy: UserOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): UserConnection!
  node(id: ID!): Node
}

type Subscription {
  image(where: ImageSubscriptionWhereInput): ImageSubscriptionPayload
  order(where: OrderSubscriptionWhereInput): OrderSubscriptionPayload
  price(where: PriceSubscriptionWhereInput): PriceSubscriptionPayload
  product(where: ProductSubscriptionWhereInput): ProductSubscriptionPayload
  productConfiguration(where: ProductConfigurationSubscriptionWhereInput): ProductConfigurationSubscriptionPayload
  productOrder(where: ProductOrderSubscriptionWhereInput): ProductOrderSubscriptionPayload
  topping(where: ToppingSubscriptionWhereInput): ToppingSubscriptionPayload
  toppingOrder(where: ToppingOrderSubscriptionWhereInput): ToppingOrderSubscriptionPayload
  user(where: UserSubscriptionWhereInput): UserSubscriptionPayload
}

type Topping {
  id: ID!
  name: String!
  prices(where: PriceWhereInput, orderBy: PriceOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Price!]
  image: Image!
  description: String!
  maxQuantity: Int
}

type ToppingConnection {
  pageInfo: PageInfo!
  edges: [ToppingEdge]!
  aggregate: AggregateTopping!
}

input ToppingCreateInput {
  id: ID
  name: String!
  prices: PriceCreateManyInput
  image: ImageCreateOneInput!
  description: String!
  maxQuantity: Int
}

input ToppingCreateManyInput {
  create: [ToppingCreateInput!]
  connect: [ToppingWhereUniqueInput!]
}

input ToppingCreateOneInput {
  create: ToppingCreateInput
  connect: ToppingWhereUniqueInput
}

type ToppingEdge {
  node: Topping!
  cursor: String!
}

type ToppingOrder {
  id: ID!
  topping: Topping!
  createdAt: DateTime!
  quantity: Int
}

enum ToppingOrderByInput {
  id_ASC
  id_DESC
  name_ASC
  name_DESC
  description_ASC
  description_DESC
  maxQuantity_ASC
  maxQuantity_DESC
}

type ToppingOrderConnection {
  pageInfo: PageInfo!
  edges: [ToppingOrderEdge]!
  aggregate: AggregateToppingOrder!
}

input ToppingOrderCreateInput {
  id: ID
  topping: ToppingCreateOneInput!
  quantity: Int
}

input ToppingOrderCreateManyInput {
  create: [ToppingOrderCreateInput!]
  connect: [ToppingOrderWhereUniqueInput!]
}

type ToppingOrderEdge {
  node: ToppingOrder!
  cursor: String!
}

enum ToppingOrderOrderByInput {
  id_ASC
  id_DESC
  createdAt_ASC
  createdAt_DESC
  quantity_ASC
  quantity_DESC
}

type ToppingOrderPreviousValues {
  id: ID!
  createdAt: DateTime!
  quantity: Int
}

input ToppingOrderScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  AND: [ToppingOrderScalarWhereInput!]
  OR: [ToppingOrderScalarWhereInput!]
  NOT: [ToppingOrderScalarWhereInput!]
}

type ToppingOrderSubscriptionPayload {
  mutation: MutationType!
  node: ToppingOrder
  updatedFields: [String!]
  previousValues: ToppingOrderPreviousValues
}

input ToppingOrderSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ToppingOrderWhereInput
  AND: [ToppingOrderSubscriptionWhereInput!]
  OR: [ToppingOrderSubscriptionWhereInput!]
  NOT: [ToppingOrderSubscriptionWhereInput!]
}

input ToppingOrderUpdateDataInput {
  topping: ToppingUpdateOneRequiredInput
  quantity: Int
}

input ToppingOrderUpdateInput {
  topping: ToppingUpdateOneRequiredInput
  quantity: Int
}

input ToppingOrderUpdateManyDataInput {
  quantity: Int
}

input ToppingOrderUpdateManyInput {
  create: [ToppingOrderCreateInput!]
  update: [ToppingOrderUpdateWithWhereUniqueNestedInput!]
  upsert: [ToppingOrderUpsertWithWhereUniqueNestedInput!]
  delete: [ToppingOrderWhereUniqueInput!]
  connect: [ToppingOrderWhereUniqueInput!]
  set: [ToppingOrderWhereUniqueInput!]
  disconnect: [ToppingOrderWhereUniqueInput!]
  deleteMany: [ToppingOrderScalarWhereInput!]
  updateMany: [ToppingOrderUpdateManyWithWhereNestedInput!]
}

input ToppingOrderUpdateManyMutationInput {
  quantity: Int
}

input ToppingOrderUpdateManyWithWhereNestedInput {
  where: ToppingOrderScalarWhereInput!
  data: ToppingOrderUpdateManyDataInput!
}

input ToppingOrderUpdateWithWhereUniqueNestedInput {
  where: ToppingOrderWhereUniqueInput!
  data: ToppingOrderUpdateDataInput!
}

input ToppingOrderUpsertWithWhereUniqueNestedInput {
  where: ToppingOrderWhereUniqueInput!
  update: ToppingOrderUpdateDataInput!
  create: ToppingOrderCreateInput!
}

input ToppingOrderWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  topping: ToppingWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  quantity: Int
  quantity_not: Int
  quantity_in: [Int!]
  quantity_not_in: [Int!]
  quantity_lt: Int
  quantity_lte: Int
  quantity_gt: Int
  quantity_gte: Int
  AND: [ToppingOrderWhereInput!]
  OR: [ToppingOrderWhereInput!]
  NOT: [ToppingOrderWhereInput!]
}

input ToppingOrderWhereUniqueInput {
  id: ID
}

type ToppingPreviousValues {
  id: ID!
  name: String!
  description: String!
  maxQuantity: Int
}

input ToppingScalarWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  maxQuantity: Int
  maxQuantity_not: Int
  maxQuantity_in: [Int!]
  maxQuantity_not_in: [Int!]
  maxQuantity_lt: Int
  maxQuantity_lte: Int
  maxQuantity_gt: Int
  maxQuantity_gte: Int
  AND: [ToppingScalarWhereInput!]
  OR: [ToppingScalarWhereInput!]
  NOT: [ToppingScalarWhereInput!]
}

type ToppingSubscriptionPayload {
  mutation: MutationType!
  node: Topping
  updatedFields: [String!]
  previousValues: ToppingPreviousValues
}

input ToppingSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: ToppingWhereInput
  AND: [ToppingSubscriptionWhereInput!]
  OR: [ToppingSubscriptionWhereInput!]
  NOT: [ToppingSubscriptionWhereInput!]
}

input ToppingUpdateDataInput {
  name: String
  prices: PriceUpdateManyInput
  image: ImageUpdateOneRequiredInput
  description: String
  maxQuantity: Int
}

input ToppingUpdateInput {
  name: String
  prices: PriceUpdateManyInput
  image: ImageUpdateOneRequiredInput
  description: String
  maxQuantity: Int
}

input ToppingUpdateManyDataInput {
  name: String
  description: String
  maxQuantity: Int
}

input ToppingUpdateManyInput {
  create: [ToppingCreateInput!]
  update: [ToppingUpdateWithWhereUniqueNestedInput!]
  upsert: [ToppingUpsertWithWhereUniqueNestedInput!]
  delete: [ToppingWhereUniqueInput!]
  connect: [ToppingWhereUniqueInput!]
  set: [ToppingWhereUniqueInput!]
  disconnect: [ToppingWhereUniqueInput!]
  deleteMany: [ToppingScalarWhereInput!]
  updateMany: [ToppingUpdateManyWithWhereNestedInput!]
}

input ToppingUpdateManyMutationInput {
  name: String
  description: String
  maxQuantity: Int
}

input ToppingUpdateManyWithWhereNestedInput {
  where: ToppingScalarWhereInput!
  data: ToppingUpdateManyDataInput!
}

input ToppingUpdateOneRequiredInput {
  create: ToppingCreateInput
  update: ToppingUpdateDataInput
  upsert: ToppingUpsertNestedInput
  connect: ToppingWhereUniqueInput
}

input ToppingUpdateWithWhereUniqueNestedInput {
  where: ToppingWhereUniqueInput!
  data: ToppingUpdateDataInput!
}

input ToppingUpsertNestedInput {
  update: ToppingUpdateDataInput!
  create: ToppingCreateInput!
}

input ToppingUpsertWithWhereUniqueNestedInput {
  where: ToppingWhereUniqueInput!
  update: ToppingUpdateDataInput!
  create: ToppingCreateInput!
}

input ToppingWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  prices_every: PriceWhereInput
  prices_some: PriceWhereInput
  prices_none: PriceWhereInput
  image: ImageWhereInput
  description: String
  description_not: String
  description_in: [String!]
  description_not_in: [String!]
  description_lt: String
  description_lte: String
  description_gt: String
  description_gte: String
  description_contains: String
  description_not_contains: String
  description_starts_with: String
  description_not_starts_with: String
  description_ends_with: String
  description_not_ends_with: String
  maxQuantity: Int
  maxQuantity_not: Int
  maxQuantity_in: [Int!]
  maxQuantity_not_in: [Int!]
  maxQuantity_lt: Int
  maxQuantity_lte: Int
  maxQuantity_gt: Int
  maxQuantity_gte: Int
  AND: [ToppingWhereInput!]
  OR: [ToppingWhereInput!]
  NOT: [ToppingWhereInput!]
}

input ToppingWhereUniqueInput {
  id: ID
}

type User {
  id: ID!
  email: String!
  password: String!
  phone: String!
  name: String!
  address1: String
  address2: String
  payment: String
  orders(where: OrderWhereInput, orderBy: OrderOrderByInput, skip: Int, after: String, before: String, first: Int, last: Int): [Order!]
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserConnection {
  pageInfo: PageInfo!
  edges: [UserEdge]!
  aggregate: AggregateUser!
}

input UserCreateInput {
  id: ID
  email: String!
  password: String!
  phone: String!
  name: String!
  address1: String
  address2: String
  payment: String
  orders: OrderCreateManyWithoutUserInput
}

input UserCreateOneWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput
  connect: UserWhereUniqueInput
}

input UserCreateWithoutOrdersInput {
  id: ID
  email: String!
  password: String!
  phone: String!
  name: String!
  address1: String
  address2: String
  payment: String
}

type UserEdge {
  node: User!
  cursor: String!
}

enum UserOrderByInput {
  id_ASC
  id_DESC
  email_ASC
  email_DESC
  password_ASC
  password_DESC
  phone_ASC
  phone_DESC
  name_ASC
  name_DESC
  address1_ASC
  address1_DESC
  address2_ASC
  address2_DESC
  payment_ASC
  payment_DESC
  createdAt_ASC
  createdAt_DESC
  updatedAt_ASC
  updatedAt_DESC
}

type UserPreviousValues {
  id: ID!
  email: String!
  password: String!
  phone: String!
  name: String!
  address1: String
  address2: String
  payment: String
  createdAt: DateTime!
  updatedAt: DateTime!
}

type UserSubscriptionPayload {
  mutation: MutationType!
  node: User
  updatedFields: [String!]
  previousValues: UserPreviousValues
}

input UserSubscriptionWhereInput {
  mutation_in: [MutationType!]
  updatedFields_contains: String
  updatedFields_contains_every: [String!]
  updatedFields_contains_some: [String!]
  node: UserWhereInput
  AND: [UserSubscriptionWhereInput!]
  OR: [UserSubscriptionWhereInput!]
  NOT: [UserSubscriptionWhereInput!]
}

input UserUpdateInput {
  email: String
  password: String
  phone: String
  name: String
  address1: String
  address2: String
  payment: String
  orders: OrderUpdateManyWithoutUserInput
}

input UserUpdateManyMutationInput {
  email: String
  password: String
  phone: String
  name: String
  address1: String
  address2: String
  payment: String
}

input UserUpdateOneWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput
  update: UserUpdateWithoutOrdersDataInput
  upsert: UserUpsertWithoutOrdersInput
  delete: Boolean
  disconnect: Boolean
  connect: UserWhereUniqueInput
}

input UserUpdateWithoutOrdersDataInput {
  email: String
  password: String
  phone: String
  name: String
  address1: String
  address2: String
  payment: String
}

input UserUpsertWithoutOrdersInput {
  update: UserUpdateWithoutOrdersDataInput!
  create: UserCreateWithoutOrdersInput!
}

input UserWhereInput {
  id: ID
  id_not: ID
  id_in: [ID!]
  id_not_in: [ID!]
  id_lt: ID
  id_lte: ID
  id_gt: ID
  id_gte: ID
  id_contains: ID
  id_not_contains: ID
  id_starts_with: ID
  id_not_starts_with: ID
  id_ends_with: ID
  id_not_ends_with: ID
  email: String
  email_not: String
  email_in: [String!]
  email_not_in: [String!]
  email_lt: String
  email_lte: String
  email_gt: String
  email_gte: String
  email_contains: String
  email_not_contains: String
  email_starts_with: String
  email_not_starts_with: String
  email_ends_with: String
  email_not_ends_with: String
  password: String
  password_not: String
  password_in: [String!]
  password_not_in: [String!]
  password_lt: String
  password_lte: String
  password_gt: String
  password_gte: String
  password_contains: String
  password_not_contains: String
  password_starts_with: String
  password_not_starts_with: String
  password_ends_with: String
  password_not_ends_with: String
  phone: String
  phone_not: String
  phone_in: [String!]
  phone_not_in: [String!]
  phone_lt: String
  phone_lte: String
  phone_gt: String
  phone_gte: String
  phone_contains: String
  phone_not_contains: String
  phone_starts_with: String
  phone_not_starts_with: String
  phone_ends_with: String
  phone_not_ends_with: String
  name: String
  name_not: String
  name_in: [String!]
  name_not_in: [String!]
  name_lt: String
  name_lte: String
  name_gt: String
  name_gte: String
  name_contains: String
  name_not_contains: String
  name_starts_with: String
  name_not_starts_with: String
  name_ends_with: String
  name_not_ends_with: String
  address1: String
  address1_not: String
  address1_in: [String!]
  address1_not_in: [String!]
  address1_lt: String
  address1_lte: String
  address1_gt: String
  address1_gte: String
  address1_contains: String
  address1_not_contains: String
  address1_starts_with: String
  address1_not_starts_with: String
  address1_ends_with: String
  address1_not_ends_with: String
  address2: String
  address2_not: String
  address2_in: [String!]
  address2_not_in: [String!]
  address2_lt: String
  address2_lte: String
  address2_gt: String
  address2_gte: String
  address2_contains: String
  address2_not_contains: String
  address2_starts_with: String
  address2_not_starts_with: String
  address2_ends_with: String
  address2_not_ends_with: String
  payment: String
  payment_not: String
  payment_in: [String!]
  payment_not_in: [String!]
  payment_lt: String
  payment_lte: String
  payment_gt: String
  payment_gte: String
  payment_contains: String
  payment_not_contains: String
  payment_starts_with: String
  payment_not_starts_with: String
  payment_ends_with: String
  payment_not_ends_with: String
  orders_every: OrderWhereInput
  orders_some: OrderWhereInput
  orders_none: OrderWhereInput
  createdAt: DateTime
  createdAt_not: DateTime
  createdAt_in: [DateTime!]
  createdAt_not_in: [DateTime!]
  createdAt_lt: DateTime
  createdAt_lte: DateTime
  createdAt_gt: DateTime
  createdAt_gte: DateTime
  updatedAt: DateTime
  updatedAt_not: DateTime
  updatedAt_in: [DateTime!]
  updatedAt_not_in: [DateTime!]
  updatedAt_lt: DateTime
  updatedAt_lte: DateTime
  updatedAt_gt: DateTime
  updatedAt_gte: DateTime
  AND: [UserWhereInput!]
  OR: [UserWhereInput!]
  NOT: [UserWhereInput!]
}

input UserWhereUniqueInput {
  id: ID
  email: String
}
`
      }
    